<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>PropIntelli - Search</title>
	<link rel="stylesheet" href="styles.css" />
	<style>
	</style>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<!-- Leaflet CSS -->
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
	<!-- Leaflet JavaScript -->
	<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
	<!-- Application State Manager - Centralized state management for cross-page persistence -->
	<script src="app-state.js"></script>
	<!-- App Data Manager - Centralized data management for cross-page data sharing -->
	<script src="app-data-manager.js"></script>
</head>
<body>
	<header class="header">
		<div class="container header-inner">
			<div class="logo"><a href="index.html" style="text-decoration: none; color: inherit;"><img src="Logo.png" alt="PropIntelli" /></a></div>
			<nav class="nav">
				<a href="index.html">Home</a>
				<a href="search.html">Properties</a>
				<a href="insights.html">Neighborhood Insights</a>
				<a href="#">About Us</a>
			</nav>
			<div class="spacer"></div>
			<div class="auth-buttons">
				<a class="button" href="auth.html">Login</a>
			</div>
		</div>
		<div class="container header-inner" style="padding-top:0;">
			<div class="search-bar">
				<div class="filters">
					<div class="group">
						<input type="text" id="selectedCity" placeholder="Enter city name (e.g., Madrid, Barcelona)" style="background: #fff;" />
					<select id="radiusSelect">
						<option value="">Search Radius (km)</option>
							<option value="1">1 km</option>
							<option value="2">2 km</option>
							<option value="5">5 km</option>
							<option value="10">10 km</option>
							<option value="15">15 km</option>
							<option value="20">20 km</option>
							<option value="25">25 km</option>
							<option value="50">50 km</option>
						</select>
					</div>
					<div class="group">
						<div class="price-popover-container">
							<button type="button" class="price-trigger" id="priceTrigger" aria-haspopup="true" aria-expanded="false">
								Price
							</button>
							<div class="price-popover" id="pricePopover" role="dialog" aria-labelledby="priceTrigger" style="display: none;">
								<div class="popover-content">
									<div class="popover-header">
										<h3>Price Range</h3>
									</div>
									<div class="popover-body">
										<div class="input-group">
											<label for="minPrice">Min (‚Ç¨)</label>
											<input type="number" id="minPrice" placeholder="0" min="0" />
										</div>
										<div class="input-group">
											<label for="maxPrice">Max (‚Ç¨)</label>
											<input type="number" id="maxPrice" placeholder="No limit" min="0" />
										</div>
										<div class="error-message" id="priceError" style="display: none;">
											Min price cannot be greater than max price
										</div>
									</div>
									<div class="popover-footer">
										<button type="button" class="btn-secondary" id="priceClear">Clear</button>
										<button type="button" class="btn-secondary" id="priceCancel">Cancel</button>
										<button type="button" class="btn-primary" id="priceApply">Apply</button>
									</div>
								</div>
							</div>
						</div>
						<div class="size-popover-container">
							<button type="button" class="size-trigger" id="sizeTrigger" aria-haspopup="true" aria-expanded="false">
								Size
							</button>
							<div class="size-popover" id="sizePopover" role="dialog" aria-labelledby="sizeTrigger" style="display: none;">
								<div class="popover-content">
									<div class="popover-header">
										<h3>Size Range</h3>
									</div>
									<div class="popover-body">
										<div class="input-group">
											<label for="minSize">Min (m¬≤)</label>
											<input type="number" id="minSize" placeholder="0" min="0" />
										</div>
										<div class="input-group">
											<label for="maxSize">Max (m¬≤)</label>
											<input type="number" id="maxSize" placeholder="No limit" min="0" />
										</div>
										<div class="error-message" id="sizeError" style="display: none;">
											Min size cannot be greater than max size
										</div>
									</div>
									<div class="popover-footer">
										<button type="button" class="btn-secondary" id="sizeClear">Clear</button>
										<button type="button" class="btn-secondary" id="sizeCancel">Cancel</button>
										<button type="button" class="btn-primary" id="sizeApply">Apply</button>
									</div>
								</div>
							</div>
						</div>
						<div class="rooms-popover-container">
							<button type="button" class="rooms-trigger" id="roomsTrigger" aria-haspopup="true" aria-expanded="false">
								Rooms
							</button>
							<div class="rooms-popover" id="roomsPopover" role="dialog" aria-labelledby="roomsTrigger" style="display: none;">
								<div class="popover-content">
									<div class="popover-header">
										<h3>Rooms Range</h3>
									</div>
									<div class="popover-body">
										<div class="input-group">
											<label for="minRooms">Min</label>
											<input type="number" id="minRooms" placeholder="0" min="0" />
										</div>
										<div class="input-group">
											<label for="maxRooms">Max</label>
											<input type="number" id="maxRooms" placeholder="No limit" min="0" />
										</div>
										<div class="error-message" id="roomsError" style="display: none;">
											Min rooms cannot be greater than max rooms
										</div>
									</div>
									<div class="popover-footer">
										<button type="button" class="btn-secondary" id="roomsClear">Clear</button>
										<button type="button" class="btn-secondary" id="roomsCancel">Cancel</button>
										<button type="button" class="btn-primary" id="roomsApply">Apply</button>
									</div>
								</div>
							</div>
						</div>
					</div>
					<div class="group">
						<select id="type" name="type" aria-label="Type">
							<option value="" selected>Any Type</option>
							<option value="apartment">Apartment</option>
							<option value="house">House</option>
							<option value="condo">Condo</option>
							<option value="townhouse">Townhouse</option>
							<option value="land">Land</option>
							<option value="new_build">New Build</option>
							<option value="investment">Investment</option>
							<option value="rent">For Rent</option>
							<option value="sale">For Sale</option>
						</select>
						<select>
							<option value="">Any</option>
							<option value="new_build">New build</option>
							<option value="fully_renovated">Fully renovated</option>
							<option value="move_in_ready">Move-in ready (good condition)</option>
							<option value="cosmetic_refresh">Needs cosmetic work</option>
							<option value="full_renovation">Needs full renovation</option>
						</select>
					</div>
				</div>
				<button class="button" id="filterButton" style="padding: 10px 14px; display: flex; align-items: center; justify-content: center;">
					<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 0;">
						<path d="M2 4h12M4 8h8M6 12h4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
					</svg>
				</button>
				<button class="button" id="downloadApiBtn" style="font-size: 14px; padding: 10px 16px; background: #488E98; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;" title="Download API Response as JSON">
					üì• Download API
				</button>
				<button class="button primary" id="searchButton">Search</button>
			</div>
		</div>
	</header>

	<!-- Advanced Filter Panel (Modal/Sticky) -->
	<div id="filterPanelOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 1000; backdrop-filter: blur(2px); align-items: center; justify-content: center;">
		<div id="filterPanel" style="position: relative; width: 90%; max-width: 500px; max-height: 90vh; background: #fff; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); border-radius: 12px; overflow: hidden; transform: scale(0.9); opacity: 0; transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; z-index: 1001; display: flex; flex-direction: column;">
			<!-- Panel Header -->
			<div style="position: sticky; top: 0; background: #fff; border-bottom: 1px solid #e5e7eb; padding: 16px 20px; display: flex; justify-content: space-between; align-items: center; z-index: 10;">
				<h2 style="margin: 0; font-size: 20px; font-weight: 600; color: #111827;">Advanced Filters</h2>
				<button id="closeFilterPanel" style="background: none; border: none; font-size: 24px; color: #6b7280; cursor: pointer; padding: 4px; line-height: 1; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='none'">
					√ó
				</button>
			</div>

			<!-- Panel Content -->
			<div style="padding: 20px; overflow-y: auto; flex: 1;">
				<!-- Price Filter -->
				<div style="margin-bottom: 24px;">
					<label style="display: block; font-weight: 600; margin-bottom: 12px; color: #374151; font-size: 14px;">Price Range (‚Ç¨)</label>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
						<div>
							<label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 6px;">Min</label>
							<input type="number" id="advancedMinPrice" placeholder="0" min="0" style="width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;" />
						</div>
						<div>
							<label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 6px;">Max</label>
							<input type="number" id="advancedMaxPrice" placeholder="No limit" min="0" style="width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;" />
						</div>
					</div>
				</div>

				<!-- Size Filter -->
				<div style="margin-bottom: 24px;">
					<label style="display: block; font-weight: 600; margin-bottom: 12px; color: #374151; font-size: 14px;">Size Range (m¬≤)</label>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
						<div>
							<label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 6px;">Min</label>
							<input type="number" id="advancedMinSize" placeholder="0" min="0" style="width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;" />
						</div>
						<div>
							<label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 6px;">Max</label>
							<input type="number" id="advancedMaxSize" placeholder="No limit" min="0" style="width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;" />
						</div>
					</div>
				</div>

				<!-- Rooms Filter -->
				<div style="margin-bottom: 24px;">
					<label style="display: block; font-weight: 600; margin-bottom: 12px; color: #374151; font-size: 14px;">Number of Rooms</label>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
						<div>
							<label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 6px;">Min</label>
							<input type="number" id="advancedMinRooms" placeholder="0" min="0" style="width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;" />
						</div>
						<div>
							<label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 6px;">Max</label>
							<input type="number" id="advancedMaxRooms" placeholder="No limit" min="0" style="width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;" />
						</div>
					</div>
				</div>

				<!-- Property Type -->
				<div style="margin-bottom: 24px;">
					<label style="display: block; font-weight: 600; margin-bottom: 12px; color: #374151; font-size: 14px;">Property Type</label>
					<select id="advancedPropertyType" style="width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; background: #fff;">
						<option value="">Any Type</option>
						<option value="apartment">Apartment</option>
						<option value="house">House</option>
						<option value="condo">Condo</option>
						<option value="townhouse">Townhouse</option>
						<option value="land">Land</option>
						<option value="new_build">New Build</option>
					</select>
				</div>

				<!-- Condition -->
				<div style="margin-bottom: 24px;">
					<label style="display: block; font-weight: 600; margin-bottom: 12px; color: #374151; font-size: 14px;">Condition</label>
					<select id="advancedCondition" style="width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; background: #fff;">
						<option value="">Any Condition</option>
						<option value="new_build">New build</option>
						<option value="fully_renovated">Fully renovated</option>
						<option value="move_in_ready">Move-in ready</option>
						<option value="cosmetic_refresh">Needs cosmetic work</option>
						<option value="full_renovation">Needs full renovation</option>
					</select>
				</div>

				<!-- Features -->
				<div style="margin-bottom: 24px;">
					<label style="display: block; font-weight: 600; margin-bottom: 12px; color: #374151; font-size: 14px;">Features</label>
					<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
						<label style="display: flex; align-items: center; gap: 8px; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px;">
							<input type="checkbox" id="featureParking" style="width: 18px; height: 18px; cursor: pointer;" />
							<span>üÖøÔ∏è Parking</span>
						</label>
						<label style="display: flex; align-items: center; gap: 8px; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px;">
							<input type="checkbox" id="featureBalcony" style="width: 18px; height: 18px; cursor: pointer;" />
							<span>üå≥ Balcony</span>
						</label>
						<label style="display: flex; align-items: center; gap: 8px; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px;">
							<input type="checkbox" id="featureGarden" style="width: 18px; height: 18px; cursor: pointer;" />
							<span>üåø Garden</span>
						</label>
						<label style="display: flex; align-items: center; gap: 8px; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px;">
							<input type="checkbox" id="featureElevator" style="width: 18px; height: 18px; cursor: pointer;" />
							<span>üõó Elevator</span>
						</label>
						<label style="display: flex; align-items: center; gap: 8px; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px;">
							<input type="checkbox" id="featurePool" style="width: 18px; height: 18px; cursor: pointer;" />
							<span>üèä Pool</span>
						</label>
						<label style="display: flex; align-items: center; gap: 8px; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px;">
							<input type="checkbox" id="featureAC" style="width: 18px; height: 18px; cursor: pointer;" />
							<span>‚ùÑÔ∏è Air Conditioning</span>
						</label>
					</div>
				</div>

				<!-- Panel Footer -->
				<div style="position: sticky; bottom: 0; background: #fff; border-top: 1px solid #e5e7eb; padding: 16px 0; margin-top: 24px; display: flex; gap: 12px;">
					<button id="clearAllFilters" style="flex: 1; padding: 12px; border: 1px solid #d1d5db; background: #fff; border-radius: 6px; font-size: 14px; font-weight: 500; color: #374151; cursor: pointer;">
						Clear All
					</button>
					<button id="applyFilters" style="flex: 1; padding: 12px; border: none; background: #488E98; color: #fff; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer;">
						Apply Filters
					</button>
				</div>
			</div>
		</div>
	</div>

	<main class="main">
		<!-- Results JSON Section (Hidden) -->
		<div id="resultsSection" style="display: none !important; margin: 2rem 0;">
			<div class="container">
				<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
					<h2 style="margin: 0;">API Response (Raw JSON)</h2>
					<button id="downloadJsonBtn" class="button" style="font-size: 12px; padding: 6px 12px; background: #488E98; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">
						üì• Download JSON
					</button>
				</div>
				<div id="resultsJsonContainer" style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 1rem; margin-top: 1rem;">
					<pre id="resultsJson" style="margin: 0; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.4; color: #333; white-space: pre-wrap; word-wrap: break-word; max-height: 600px; overflow-y: auto;"></pre>
				</div>
				<div id="noResults" style="display: none; text-align: center; padding: 2rem; color: #6b7280;">
					<p>No data returned from API.</p>
				</div>
			</div>
		</div>

		<div class="container two-col">
			<section class="stack">
				<!-- Summary Section -->
				<div class="card" style="margin-bottom: 20px;">
					<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
						<h3 style="margin: 0;">Area Summary</h3>
					</div>
					<div id="areaSummary" style="background: #f8f9fa; border-radius: 8px; padding: 20px; border-left: 4px solid #488E98;">
						<div id="summaryContent" style="font-size: 14px; line-height: 1.6; color: #333;">
							<div style="display: flex; align-items: center; margin-bottom: 15px;">
								<div style="width: 40px; height: 40px; background: #488E98; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 15px;">
									<span style="color: white; font-size: 18px;">üìä</span>
								</div>
								<div>
									<h6 style="margin: 0; color: #488E98; font-weight: 600;">Demographic Analysis</h6>
									<p style="margin: 0; font-size: 12px; color: #666;">AI-powered insights</p>
								</div>
							</div>
							<div id="summaryText" style="font-style: italic; color: #555;">
								Select a location to generate area insights...
							</div>
						</div>
					</div>
				</div>

				<div class="card" style="position: relative;">
					<h3>Crime Rate</h3>
					<p style="font-size: 12px; color: #6b7280; margin: -8px 0 12px 0; font-style: italic;">Municipality-wide crime data normalized by municipality population</p>
					<div style="position: absolute; top: 10px; right: 10px; display: none;" id="crimeSortControls">
						<button id="crimeSortButton" style="background: #488E98; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 11px; cursor: pointer; margin-right: 5px;" onclick="toggleCrimeSort()">
							Sort by: Severity
						</button>
						<button id="crimeOrderButton" style="background: #6b7280; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 11px; cursor: pointer;" onclick="toggleCrimeOrder()">
							‚Üì Desc
						</button>
					</div>
					<div id="crimeVisualization">
						<div class="placeholder">Crime data will appear here after search</div>
					</div>
				</div>
				<div class="card demographics-card">
					<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
						<h3 style="margin: 0;">Demographics</h3>
						<button id="toggleDemographicsChart" class="button" style="font-size: 12px; padding: 4px 8px; background: #488E98; color: white; border: none; border-radius: 4px; cursor: pointer;">
							Switch to Table View
						</button>
					</div>
					
					<!-- Population Overview Section -->
					<div id="populationOverview" style="margin-bottom: 20px;">
						<div class="kpi-card" style="text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 8px; margin-bottom: 12px;">
							<div class="kpi-main">
								<h2 class="kpi-value" id="totalPopulation" style="font-size: 2.2rem; font-weight: 700; margin: 0; color: #488E98;">-</h2>
								<p class="kpi-label" id="populationLabel" style="margin: 4px 0 0 0; font-size: 16px; color: #6b7280;">Total Population</p>
							</div>
							<div id="populationDensity" style="margin: 8px 0;">
								<h3 class="kpi-value" id="densityValue" style="font-size: 1.5rem; font-weight: 600; margin: 0; color: #059669;">-</h3>
								<p class="kpi-label" style="margin: 2px 0 0 0; font-size: 14px; color: #6b7280;">Population Density</p>
							</div>
							<div id="populationPercentage" style="margin: 8px 0;">
								<h3 class="kpi-value" id="percentageValue" style="font-size: 1.3rem; font-weight: 600; margin: 0; color: #7c3aed;">-</h3>
								<p class="kpi-label" style="margin: 2px 0 0 0; font-size: 14px; color: #6b7280;">of Municipality</p>
							</div>
							<p class="kpi-subtext" id="populationSource" style="font-size: 0.85rem; color: #777; margin: 8px 0 0 0;">Population data unavailable for this section.</p>
							<p class="kpi-area" id="populationArea" style="font-size: 0.75rem; color: #999; margin: 4px 0 0 0; font-style: italic;"></p>
						</div>
					</div>

					<!-- Gender Distribution and Education Breakdown - Side by Side -->
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
					<!-- Gender Composition Chart -->
						<div>
						<h5 style="margin: 0 0 10px 0;">Gender Distribution</h5>
						<div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: #fff; height: 200px; display: flex; align-items: center; justify-content: center;">
							<canvas id="genderChart" style="max-width: 100%; max-height: 100%;"></canvas>
						</div>
						<div id="genderSummary" style="text-align: center; margin-top: 12px; font-size: 14px; color: #6b7280;"></div>
					</div>
					
				<!-- Education Chart -->
						<div>
					<h5 style="margin: 0 0 10px 0;">Education Breakdown</h5>
					<div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: #fff; height: 200px; display: flex; align-items: center; justify-content: center;">
						<canvas id="educationChart" style="max-width: 100%; max-height: 100%;"></canvas>
							</div>
					</div>
				</div>

				<!-- Income Distribution Bar Chart -->
				<div style="margin-bottom: 5px;">
					<h5 style="margin: 0 0 10px 0;">Income Distribution</h5>
					<div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: #fff; height: 250px; display: flex; align-items: center; justify-content: center;">
						<canvas id="incomeDistributionChart" style="max-width: 100%; max-height: 100%;"></canvas>
					</div>
				</div>

				<!-- Income Chart -->
				<div>
					<canvas id="incomeChart" style="height: 250px;"></canvas>
				</div>

				<!-- Income Distribution Map -->
				<div style="margin-top: 5px;">
					<h5 style="margin: 0 0 10px 0;">Income Distribution by Census Section</h5>
					<div id="incomeMap" style="height: 400px; border: 1px solid #dee2e6; border-radius: 4px;"></div>
					<div id="incomeMapLegend" style="margin-top: 10px; text-align: center; font-size: 12px; color: #666;"></div>
				</div>

				<!-- Ethnicity & Nationality Chart -->
				<div style="margin-top: 20px;">
					<h5 style="margin: 0 0 10px 0;">Population by Origin</h5>
					<div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: #fff; height: 300px; display: flex; align-items: center; justify-content: center;">
						<div id="ethnicityChart" style="width: 100%; height: 100%;"></div>
					</div>
				</div>


				<!-- Age Distribution Chart -->
				<div style="margin-top: 20px;">
					<div style="margin-bottom: 10px;">
						<h5 style="margin: 0;">Age Distribution</h5>
					</div>
					<div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: #fff; height: 400px; display: flex; align-items: center; justify-content: center;">
						<div id="ageDistributionChart" style="width: 100%; height: 100%;"></div>
					</div>
				</div>
					
					<!-- Table View (Hidden by default) -->
					<div id="demographicsTableContainer" style="display: none;">
						<table class="table">
							<thead>
								<tr>
									<th>Category</th>
									<th>Indicator</th>
									<th>Value</th>
									<th>Year</th>
									<th>Source</th>
								</tr>
							</thead>
							<tbody id="demographicsTableBody">
								<tr>
									<td colspan="5" style="text-align: center; color: #6b7280; padding: 20px;">Demographics data will appear here after search</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<div class="card infrastructure-card">
					<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
						<h3 style="margin: 0;">Infrastructure</h3>
						<select id="infrastructureFilter" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
							<option value="all">All Types</option>
							<option value="hospital">Hospitals</option>
							<option value="pharmacy">Pharmacies</option>
							<option value="school">Schools</option>
							<option value="supermarket">Supermarkets</option>
						</select>
					</div>

					<!-- KPI Counters -->
					<div id="infrastructureKPIs" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 16px;">
						<div class="kpi-counter" style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 8px;">
							<div style="font-size: 24px; font-weight: bold; color: #dc2626;">-</div>
							<div style="font-size: 12px; color: #6b7280;">Hospitals</div>
						</div>
						<div class="kpi-counter" style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 8px;">
							<div style="font-size: 24px; font-weight: bold; color: #059669;">-</div>
							<div style="font-size: 12px; color: #6b7280;">Pharmacies</div>
						</div>
						<div class="kpi-counter" style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 8px;">
							<div style="font-size: 24px; font-weight: bold; color: #2563eb;">-</div>
							<div style="font-size: 12px; color: #6b7280;">Schools</div>
						</div>
						<div class="kpi-counter" style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 8px;">
							<div style="font-size: 24px; font-weight: bold; color: #7c3aed;">-</div>
							<div style="font-size: 12px; color: #6b7280;">Supermarkets</div>
						</div>
					</div>

					<!-- Map and Table Container -->
					<div style="display: flex; gap: 16px; height: 400px;">
						<!-- Interactive Map -->
						<div style="flex: 1; border: 1px solid #dee2e6; border-radius: 4px; background: #fff; position: relative;">
							<div id="infrastructureMap" style="width: 100%; height: 100%; border-radius: 4px;"></div>
						</div>

						<!-- Infrastructure Table -->
						<div style="flex: 1; border: 1px solid #dee2e6; border-radius: 4px; background: #fff; overflow: hidden;">
							<div style="padding: 12px; border-bottom: 1px solid #dee2e6; background: #f8f9fa; font-weight: 600; font-size: 14px;">
								Infrastructure List
							</div>
							<div id="infrastructureTable" style="height: calc(100% - 45px); overflow-y: auto;">
								<div style="padding: 20px; text-align: center; color: #6b7280;">
									Infrastructure data will appear here after search
								</div>
							</div>
						</div>
					</div>

				</div>
				<!-- Market Analytics -->
				<div class="card">
					<h3>Market Analytics</h3>
					<div id="marketAnalyticsContainer" style="display: none;">
						<!-- Market KPIs -->
						<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px; margin-bottom: 20px;">
							<div style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 6px;">
								<div style="font-size: 24px; font-weight: bold; color: #4287f5;">üè∑Ô∏è</div>
								<div style="font-size: 12px; color: #666; margin-bottom: 4px;">Average Price</div>
								<div id="avgPrice" style="font-size: 18px; font-weight: bold; color: #333;">‚Ç¨0</div>
							</div>
							<div style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 6px;">
								<div style="font-size: 24px; font-weight: bold; color: #4287f5;">üí∞</div>
								<div style="font-size: 12px; color: #666; margin-bottom: 4px;">Median Price</div>
								<div id="medianPrice" style="font-size: 18px; font-weight: bold; color: #333;">‚Ç¨0</div>
							</div>
							<div style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 6px;">
								<div style="font-size: 24px; font-weight: bold; color: #4287f5;">üìä</div>
								<div style="font-size: 12px; color: #666; margin-bottom: 4px;">Listings Count</div>
								<div id="listingsCount" style="font-size: 18px; font-weight: bold; color: #333;">0</div>
							</div>
							<div style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 6px;">
								<div style="font-size: 24px; font-weight: bold; color: #4287f5;">üìê</div>
								<div style="font-size: 12px; color: #666; margin-bottom: 4px;">Median Size</div>
								<div id="medianSize" style="font-size: 18px; font-weight: bold; color: #333;">0 m¬≤</div>
							</div>
							<div style="text-align: center; padding: 12px; background: #f8f9fa; border-radius: 6px;">
								<div style="font-size: 24px; font-weight: bold; color: #4287f5;">üí≤</div>
								<div style="font-size: 12px; color: #666; margin-bottom: 4px;">Avg Price/m¬≤</div>
								<div id="avgPricePerSqm" style="font-size: 18px; font-weight: bold; color: #333;">‚Ç¨0</div>
							</div>
						</div>

						<!-- Charts Row - Stacked vertically for more space -->
						<div style="display: flex; flex-direction: column; gap: 20px; margin-bottom: 20px;">
							<!-- Price Distribution Chart -->
							<div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; background: #fff;">
								<h5 style="margin: 0 0 15px 0; font-size: 14px; color: #333;">Price Distribution</h5>
								<div id="priceDistributionChart" style="width: 100%; height: 400px;"></div>
							</div>

							<!-- Price vs Size Scatter Plot -->
							<div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; background: #fff;">
								<h5 style="margin: 0 0 15px 0; font-size: 14px; color: #333;">Price vs Size</h5>
								<div id="priceSizeScatterChart" style="width: 100%; height: 400px;"></div>
							</div>
						</div>

						<!-- Market Summary -->
						<div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #4287f5;">
							<h6 style="margin: 0 0 8px 0; color: #333;">Market Summary</h6>
							<div id="marketSummary" style="font-size: 14px; color: #666; line-height: 1.4;">
								Analyzing property data...
							</div>
						</div>
					</div>
					<div id="marketAnalyticsPlaceholder" class="placeholder">Market analytics will appear here after search</div>
				</div>
				<div class="card"><h3>Analytics Tools</h3>
					<div class="grid" style="grid-template-columns: repeat(3, minmax(0, 1fr));">
						<div class="placeholder">Price / sqm</div>
						<div class="placeholder">Historical trends</div>
						<div class="placeholder">Investment estimator</div>
					</div>
				</div>
			</section>

			<aside id="listingsPanel" class="stack" data-view="list" style="align-items: flex-start; gap: 2px; position: relative;">
				<div class="card" style="display:flex; justify-content:space-between; align-items:center; padding: 0.25rem 0.5rem; height: auto; margin-bottom: 0;">
					<strong>Listings</strong>
					<div style="display: flex; gap: 8px; align-items: center;">
						<select id="sortSelect">
							<option value="">Sort by</option>
							<option value="price-low-high">Price (low ‚Üí high)</option>
							<option value="price-high-low">Price (high ‚Üí low)</option>
							<option value="size-low-high">Size (low ‚Üí high)</option>
							<option value="size-high-low">Size (high ‚Üí low)</option>
						</select>
						<button class="button" id="toggleViewBtn">Switch to Map View</button>
					</div>
				</div>
				
				<!-- Results Count Display -->
				<div id="resultsCountDisplay" style="padding: 8px 12px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; margin-bottom: 8px; font-size: 14px; font-weight: 500; color: #333;">
					<span id="resultsCount">0 Results Found</span>
				</div>
				
				<!-- Compare Button -->
				<div id="compareControls" style="display: none; margin-bottom: 16px; text-align: center;">
					<button id="compareButton" class="button primary" style="background: #488E98;">
						Compare Selected Properties (<span id="selectedCount">0</span>)
					</button>
					<button id="clearSelection" class="button" style="margin-left: 8px;">
						Clear Selection
					</button>
				</div>
				
				<!-- Map View Container (hidden by default) -->
				<div id="mapViewContainer" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; flex-direction: column; z-index: 10; background: var(--bg); padding: 8px; padding-top: 0;">
					<!-- Map Controls -->
					<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-shrink: 0; padding: 8px; background: var(--panel); border-radius: 8px;">
						<div style="display: flex; gap: 8px; align-items: center;">
							<button id="toggleHeatmap" class="btn btn-sm btn-outline-primary" style="font-size: 12px; padding: 4px 8px;">
								<span id="heatmapIcon">üî•</span> Heatmap
							</button>
							<button id="toggleMarkers" class="btn btn-sm btn-primary" style="font-size: 12px; padding: 4px 8px;">
								<span id="markersIcon">üìç</span> Markers
							</button>
						</div>
						<div style="font-size: 12px; color: #666;">
							<span id="mapPropertyCount">0</span> properties
						</div>
					</div>
					
					<!-- Map Container -->
					<div id="propertyMap" style="flex: 1; min-height: 0; border: 1px solid #dee2e6; border-radius: 4px; background: #f8f9fa;"></div>
					
					<!-- Price Legend -->
					<div id="priceLegend" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 12px; flex-shrink: 0;">
						<div style="font-weight: 600; margin-bottom: 8px;">Price Range Legend:</div>
						<div id="legendItems" style="display: flex; flex-wrap: wrap; gap: 12px;"></div>
					</div>
				</div>
				
				<div class="listings" id="listingsContainer" style="max-height: none; overflow: visible;">
					<div class="property-card">
						<div class="property-thumb"></div>
						<div>
							<div style="display:flex; align-items:center; gap:8px; justify-content:space-between;">
								<strong>$480,000</strong>
								<label class="small"><input type="checkbox" data-compare-id="p1" /> Compare</label>
							</div>
							<div class="badges">
								<span class="badge">Low renovation need</span>
								<span class="badge warn">Resale +8% est.</span>
							</div>
							<div class="property-meta"><span>85 m¬≤ ‚Ä¢ 3 rm ‚Ä¢ 2 bath</span><span>Downtown</span></div>
							<div>123 Main St ‚Ä¢ <a class="small" href="#" target="_blank">Original listing</a></div>
							<a class="small" href="property.html">View details</a>
						</div>
					</div>
					<div class="property-card">
						<div class="property-thumb"></div>
						<div>
							<div style="display:flex; align-items:center; gap:8px; justify-content:space-between;">
								<strong>$620,000</strong>
								<label class="small"><input type="checkbox" data-compare-id="p2" /> Compare</label>
							</div>
							<div class="badges">
								<span class="badge warn">Needs renovation</span>
								<span class="badge">Resale +12% est.</span>
							</div>
							<div class="property-meta"><span>110 m¬≤ ‚Ä¢ 4 rm ‚Ä¢ 2 bath</span><span>Westside</span></div>
							<div>456 Oak Ave ‚Ä¢ <a class="small" href="#" target="_blank">Original listing</a></div>
							<a class="small" href="property.html">View details</a>
						</div>
					</div>
				</div>
				
				<!-- Pagination Controls -->
				<div id="paginationContainer" style="display: none; margin: 16px 0; text-align: center;">
					<div id="paginationControls" style="display: flex; justify-content: center; align-items: center; gap: 8px; flex-wrap: wrap;">
						<!-- Pagination buttons will be inserted here -->
					</div>
					<div id="paginationInfo" style="margin-top: 8px; font-size: 12px; color: #6b7280;">
						<!-- Page info will be inserted here -->
					</div>
				</div>
				
				<div class="sticky-compare">
					<div><strong><span data-compare-count>0</span></strong> selected</div>
					<div style="display:flex; gap:8px;">
						<a class="button" href="compare.html">Compare</a>
						<button class="button primary" data-open-chat>Ask AI for best pick</button>
					</div>
				</div>
			</aside>
		</div>
	</main>

	<footer class="footer">
		<div class="container">¬© 2025 PropIntelli</div>
	</footer>

	<button class="chatbot-toggle">Chat</button>
	<div class="chatbot">
		<div class="chatbot-header">PropIntelli Assistant</div>
		<div class="chatbot-body">
			<div class="small">Ask for price per sqm or ROI ideas.</div>
		</div>
		<div class="chatbot-input">
			<input class="input" placeholder="Type your question..." />
			<button class="button primary">Send</button>
		</div>
	</div>

	<script>
		// Handle URL parameters from index page and initialize search functionality
		document.addEventListener('DOMContentLoaded', function() {
			const urlParams = new URLSearchParams(window.location.search);
			const selectedCityInput = document.getElementById('selectedCity');
			
			// Get parameters from URL
			const location = urlParams.get('location');
			const country = urlParams.get('country');
			const purpose = urlParams.get('purpose');
			
			console.log('URL Parameters:', { location, country, purpose });
			
			// Populate the selected city field
			if (location && selectedCityInput) {
				selectedCityInput.value = location;
				console.log('Selected city populated:', location);
			}
			
			// You can also use the country and purpose parameters for other functionality
			if (country) {
				console.log('Country from index:', country);
			}
			if (purpose) {
				console.log('Purpose from index:', purpose);
			}
			
			// Initialize search functionality
			initializeSearchFunctionality();
		});

		// Advanced Filter Panel functionality
		const filterButton = document.getElementById('filterButton');
		const filterPanelOverlay = document.getElementById('filterPanelOverlay');
		const filterPanel = document.getElementById('filterPanel');
		const closeFilterPanel = document.getElementById('closeFilterPanel');
		const applyFiltersBtn = document.getElementById('applyFilters');
		const clearAllFiltersBtn = document.getElementById('clearAllFilters');

		// Open filter panel
		if (filterButton && filterPanelOverlay && filterPanel) {
			filterButton.addEventListener('click', function() {
				// Load current filter values from existing filter inputs into advanced panel
				const minPriceInput = document.getElementById('minPrice');
				const maxPriceInput = document.getElementById('maxPrice');
				const minSizeInput = document.getElementById('minSize');
				const maxSizeInput = document.getElementById('maxSize');
				const minRoomsInput = document.getElementById('minRooms');
				const maxRoomsInput = document.getElementById('maxRooms');

				// Sync Price values
				if (minPriceInput && minPriceInput.value) {
					document.getElementById('advancedMinPrice').value = minPriceInput.value;
				}
				if (maxPriceInput && maxPriceInput.value) {
					document.getElementById('advancedMaxPrice').value = maxPriceInput.value;
				}

				// Sync Size values
				if (minSizeInput && minSizeInput.value) {
					document.getElementById('advancedMinSize').value = minSizeInput.value;
				}
				if (maxSizeInput && maxSizeInput.value) {
					document.getElementById('advancedMaxSize').value = maxSizeInput.value;
				}

				// Sync Rooms values
				if (minRoomsInput && minRoomsInput.value) {
					document.getElementById('advancedMinRooms').value = minRoomsInput.value;
				}
				if (maxRoomsInput && maxRoomsInput.value) {
					document.getElementById('advancedMaxRooms').value = maxRoomsInput.value;
				}

				// Open the panel
				filterPanelOverlay.style.display = 'flex';
				setTimeout(() => {
					filterPanel.style.transform = 'scale(1)';
					filterPanel.style.opacity = '1';
				}, 10);
			});
		}

		// Close filter panel
		function closeFilterPanelFunc() {
			if (filterPanel && filterPanelOverlay) {
				filterPanel.style.transform = 'scale(0.9)';
				filterPanel.style.opacity = '0';
				setTimeout(() => {
					filterPanelOverlay.style.display = 'none';
				}, 300);
			}
		}

		if (closeFilterPanel) {
			closeFilterPanel.addEventListener('click', closeFilterPanelFunc);
		}

		// Close on overlay click
		if (filterPanelOverlay) {
			filterPanelOverlay.addEventListener('click', function(e) {
				if (e.target === filterPanelOverlay) {
					closeFilterPanelFunc();
				}
			});
		}

		// Close on Escape key
		document.addEventListener('keydown', function(e) {
			if (e.key === 'Escape' && filterPanelOverlay && filterPanelOverlay.style.display === 'block') {
				closeFilterPanelFunc();
			}
		});

		// Apply filters
		if (applyFiltersBtn) {
			applyFiltersBtn.addEventListener('click', function() {
				// Get filter values from advanced panel
				const advancedMinPrice = document.getElementById('advancedMinPrice')?.value || '';
				const advancedMaxPrice = document.getElementById('advancedMaxPrice')?.value || '';
				const advancedMinSize = document.getElementById('advancedMinSize')?.value || '';
				const advancedMaxSize = document.getElementById('advancedMaxSize')?.value || '';
				const advancedMinRooms = document.getElementById('advancedMinRooms')?.value || '';
				const advancedMaxRooms = document.getElementById('advancedMaxRooms')?.value || '';
				const propertyType = document.getElementById('advancedPropertyType')?.value || '';
				const condition = document.getElementById('advancedCondition')?.value || '';
				
				// Get selected features
				const features = [];
				if (document.getElementById('featureParking')?.checked) features.push('parking');
				if (document.getElementById('featureBalcony')?.checked) features.push('balcony');
				if (document.getElementById('featureGarden')?.checked) features.push('garden');
				if (document.getElementById('featureElevator')?.checked) features.push('elevator');
				if (document.getElementById('featurePool')?.checked) features.push('pool');
				if (document.getElementById('featureAC')?.checked) features.push('air_conditioning');

				console.log('Advanced filters applied:', {
					price: { min: advancedMinPrice, max: advancedMaxPrice },
					size: { min: advancedMinSize, max: advancedMaxSize },
					rooms: { min: advancedMinRooms, max: advancedMaxRooms },
					propertyType,
					condition,
					features
				});

				// Sync with existing filter inputs (Price, Size, Rooms)
				const minPriceInput = document.getElementById('minPrice');
				const maxPriceInput = document.getElementById('maxPrice');
				const minSizeInput = document.getElementById('minSize');
				const maxSizeInput = document.getElementById('maxSize');
				const minRoomsInput = document.getElementById('minRooms');
				const maxRoomsInput = document.getElementById('maxRooms');

				// Update Price inputs
				if (minPriceInput) minPriceInput.value = advancedMinPrice;
				if (maxPriceInput) maxPriceInput.value = advancedMaxPrice;

				// Update Size inputs
				if (minSizeInput) minSizeInput.value = advancedMinSize;
				if (maxSizeInput) maxSizeInput.value = advancedMaxSize;

				// Update Rooms inputs
				if (minRoomsInput) minRoomsInput.value = advancedMinRooms;
				if (maxRoomsInput) maxRoomsInput.value = advancedMaxRooms;

				// Update filterState object
				filterState.minPrice = advancedMinPrice ? parseInt(advancedMinPrice) : null;
				filterState.maxPrice = advancedMaxPrice ? parseInt(advancedMaxPrice) : null;
				filterState.minSize = advancedMinSize ? parseInt(advancedMinSize) : null;
				filterState.maxSize = advancedMaxSize ? parseInt(advancedMaxSize) : null;
				filterState.minRooms = advancedMinRooms ? parseInt(advancedMinRooms) : null;
				filterState.maxRooms = advancedMaxRooms ? parseInt(advancedMaxRooms) : null;
				filterState.features = features; // Store selected features

				// Apply the filters
				applyFilters();

				// Close panel
				closeFilterPanelFunc();
			});
		}

		// Clear all filters
		if (clearAllFiltersBtn) {
			clearAllFiltersBtn.addEventListener('click', function() {
				// Clear advanced filter panel inputs
				document.getElementById('advancedMinPrice').value = '';
				document.getElementById('advancedMaxPrice').value = '';
				document.getElementById('advancedMinSize').value = '';
				document.getElementById('advancedMaxSize').value = '';
				document.getElementById('advancedMinRooms').value = '';
				document.getElementById('advancedMaxRooms').value = '';
				document.getElementById('advancedPropertyType').value = '';
				document.getElementById('advancedCondition').value = '';
				document.getElementById('featureParking').checked = false;
				document.getElementById('featureBalcony').checked = false;
				document.getElementById('featureGarden').checked = false;
				document.getElementById('featureElevator').checked = false;
				document.getElementById('featurePool').checked = false;
				document.getElementById('featureAC').checked = false;

				// Clear existing filter inputs (Price, Size, Rooms)
				const minPriceInput = document.getElementById('minPrice');
				const maxPriceInput = document.getElementById('maxPrice');
				const minSizeInput = document.getElementById('minSize');
				const maxSizeInput = document.getElementById('maxSize');
				const minRoomsInput = document.getElementById('minRooms');
				const maxRoomsInput = document.getElementById('maxRooms');

				if (minPriceInput) minPriceInput.value = '';
				if (maxPriceInput) maxPriceInput.value = '';
				if (minSizeInput) minSizeInput.value = '';
				if (maxSizeInput) maxSizeInput.value = '';
				if (minRoomsInput) minRoomsInput.value = '';
				if (maxRoomsInput) maxRoomsInput.value = '';

				// Clear filterState
				filterState.minPrice = null;
				filterState.maxPrice = null;
				filterState.minSize = null;
				filterState.maxSize = null;
				filterState.minRooms = null;
				filterState.maxRooms = null;
				filterState.features = []; // Clear features

				// Apply filters (to reset the filtered results)
				applyFilters();
			});
		}

		// Initialize search functionality
		function initializeSearchFunctionality() {
			const searchButton = document.getElementById('searchButton');
			const selectedCityInput = document.getElementById('selectedCity');
			const radiusSelect = document.getElementById('radiusSelect');

		if (searchButton && selectedCityInput && radiusSelect) {
			searchButton.addEventListener('click', async function() {
				const city = selectedCityInput.value;
				const radius = radiusSelect.value;

				console.log('Search button clicked with:', { city, radius });
				console.log('Input elements found:', {
					selectedCityInput: !!selectedCityInput,
					radiusSelect: !!radiusSelect,
					cityValue: city,
					radiusValue: radius
				});

				// Validate inputs
				if (!city || city.trim() === '') {
					console.error('City is required - current value:', city);
					console.log('Available URL parameters:', window.location.search);
					console.log('selectedCityInput element:', selectedCityInput);
					console.log('selectedCityInput value:', selectedCityInput ? selectedCityInput.value : 'element not found');
					alert('Please select a city first. Current city value: "' + city + '"\n\nTip: Go to the home page first to select a city, or manually enter a city name in the "Selected City" field.');
					return;
				}

				if (!radius || radius === '') {
					console.error('Radius is required - current value:', radius);
					alert('Please select a search radius. Current radius value: "' + radius + '"');
					return;
				}

				try {
					// Build the request body
					const requestBody = {
						place: city,
						radius_km: parseInt(radius)
					};

					// Store search parameters for weighted population calculation
					// Note: searchCenter will be extracted from API response in displayResults()
					searchRadiusKm = parseInt(radius);
					console.log('Search radius set:', searchRadiusKm, 'for place:', city);

					console.log('Sending API request:', requestBody);
					console.log('API endpoint:', 'https://etlt2dpwoi.execute-api.eu-central-1.amazonaws.com/dev/search');

					// Make the API call
					const response = await fetch('https://etlt2dpwoi.execute-api.eu-central-1.amazonaws.com/dev/search', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'X-Admin-Token': 'testing123'
						},
						body: JSON.stringify(requestBody)
					});

					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}

					const data = await response.json();
					console.log('API Response:', data);

					// Display the results in the table
					displayResults(data);

				} catch (error) {
					console.error('API call failed:', error);
					console.error('Error details:', {
						message: error.message,
						stack: error.stack,
						city: city,
						radius: radius,
						requestBody: requestBody
					});
					
					// Show more detailed error message
					let errorMessage = 'Search failed. ';
					if (error.message.includes('Failed to fetch')) {
						errorMessage += 'Network error - please check your internet connection.';
					} else if (error.message.includes('HTTP error')) {
						errorMessage += `Server error: ${error.message}`;
					} else {
						errorMessage += `Error: ${error.message}`;
					}
					errorMessage += ' Check console for full details.';
					
					alert(errorMessage);
				}
			});
		}

		// Function to display API results as raw JSON
		function displayResults(data) {
			console.log('[Search] üìä displayResults() called with data:', !!data);
			
			// Ensure this function is globally accessible
			if (typeof window !== 'undefined') {
				window.displayResults = displayResults;
			}
			
			// Ensure required elements exist
			const resultsSection = document.getElementById('resultsSection');
			const resultsJson = document.getElementById('resultsJson');
			const noResults = document.getElementById('noResults');
			
			if (!resultsSection) {
				console.error('[Search] ‚ùå resultsSection element not found!');
				return;
			}
			
			if (!resultsJson) {
				console.error('[Search] ‚ùå resultsJson element not found!');
				return;
			}
			
			console.log('[Search] ‚úÖ Required elements found');
			
			// Extract search center from API response if available
			console.log('=== SEARCH CENTER EXTRACTION DEBUG ===');
			console.log('Full API response data structure:', data);
			console.log('Available top-level keys:', data ? Object.keys(data) : 'No data');
			
			if (data && data.search_center) {
				searchCenter = {
					lat: parseFloat(data.search_center.lat),
					lon: parseFloat(data.search_center.lon)
				};
				console.log('Search center extracted from API response (search_center):', searchCenter);
			} else if (data && data.location) {
				// Alternative: try to extract from location data
				searchCenter = {
					lat: parseFloat(data.location.lat),
					lon: parseFloat(data.location.lon)
				};
				console.log('Search center extracted from location data:', searchCenter);
			} else if (data && data.center) {
				// Another alternative: try center field
				searchCenter = {
					lat: parseFloat(data.center.lat),
					lon: parseFloat(data.center.lon)
				};
				console.log('Search center extracted from center data:', searchCenter);
			} else if (data && data.coordinates) {
				// Another alternative: try coordinates field
				searchCenter = {
					lat: parseFloat(data.coordinates.lat),
					lon: parseFloat(data.coordinates.lon)
				};
				console.log('Search center extracted from coordinates data:', searchCenter);
			} else {
				// Fallback: use city coordinates if available
				const cityKey = document.getElementById('selectedCity')?.value?.toLowerCase().trim();
				console.log('Trying fallback city coordinates for:', cityKey);
				if (cityKey && cityCoordinates[cityKey]) {
					searchCenter = {
						lat: cityCoordinates[cityKey][0],
						lon: cityCoordinates[cityKey][1]
					};
					console.log('Using fallback city coordinates for search center:', searchCenter);
				} else {
					console.log('No search center found in API response or city coordinates, searchCenter remains:', searchCenter);
				}
			}
			console.log('Final search center:', searchCenter, 'Final radius:', searchRadiusKm);
			console.log('=== END SEARCH CENTER EXTRACTION DEBUG ===');
			
			// Generate area summary
			generateAreaSummary(data);
			const resultsJsonContainer = document.getElementById('resultsJsonContainer');

			// Show the results section (currently hidden per user request)
			// resultsSection.style.display = 'block';

			// Check if we have data
			if (!data) {
				resultsJsonContainer.style.display = 'none';
				noResults.style.display = 'block';
				noResults.innerHTML = '<p>No data returned from API.</p>';
				return;
			}

			// Hide no results message and show JSON
			noResults.style.display = 'none';
			resultsJsonContainer.style.display = 'block';

			// Display the raw JSON response
			try {
				const jsonString = JSON.stringify(data, null, 2);
				resultsJson.textContent = jsonString;
				console.log('Raw API Response:', data);
			} catch (error) {
				resultsJson.textContent = 'Error formatting JSON: ' + error.message;
				console.error('JSON formatting error:', error);
			}

			// Store the API response for re-processing when sort mode changes
			window.lastApiResponse = data;

			// Store API response using AppState (centralized state management)
			if (typeof AppState !== 'undefined') {
				AppState.setApiResponse(data);
			} else {
				console.error('[Search] ‚ùå AppState not available! Data cannot be persisted.');
			}

			// Store search parameters using AppState
			const searchParams = {
				city: document.getElementById('selectedCity')?.value || '',
				radius: searchRadiusKm || null,
				lat: searchCenter?.lat || null,
				lon: searchCenter?.lon || null
			};
			
			if (typeof AppState !== 'undefined') {
				AppState.setSearchParams(searchParams);
			} else {
				console.error('[Search] ‚ùå AppState not available! Search parameters cannot be persisted.');
			}

			// Show download button and set up download functionality
			const downloadBtn = document.getElementById('downloadJsonBtn');
			if (downloadBtn) {
				downloadBtn.style.display = 'inline-block';
				downloadBtn.onclick = () => downloadJsonData(data);
			}
			
			// Also show the main download button in the header (next to Search button)
			const downloadApiBtn = document.getElementById('downloadApiBtn');
			if (downloadApiBtn) {
				downloadApiBtn.style.display = 'inline-block';
				downloadApiBtn.onclick = () => downloadJsonData(data);
			}

			// Process crime data if available
			processCrimeData(data);
			
			// Process property listings if available
			processPropertyListings(data);
			
			// Process market analytics if available
			processMarketAnalytics(data);
			
			// Process map view if available (with error handling)
			try {
				processMapView(data);
			} catch (error) {
				console.error('Error in map view processing:', error);
			}
			
			// Process demographics data if available
			if (data && data.data && data.data.muni_stats && data.data.muni_stats.rows) {
				console.log('Demographics data found:', data.data.muni_stats.rows);
				renderDemographics(data.data.muni_stats.rows);
			} else {
				console.log('No demographics data found in API response');
				console.log('Available data keys:', data ? Object.keys(data) : 'No data');
				if (data && data.data) {
					console.log('Data.data keys:', Object.keys(data.data));
				}
			}
			
			// Process section-specific population data if available
			if (data && data.data && data.data.secc_stats && data.data.secc_stats.rows) {
				console.log('Section stats data found:', data.data.secc_stats.rows);
				
				// Also pass municipality data for percentage calculation
				const municipalityData = data.data.muni_stats && data.data.muni_stats.rows ? data.data.muni_stats.rows : null;
				renderPopulationOverview(data.data.secc_stats.rows, municipalityData);
			} else {
				console.log('No section stats data found for population overview');
			}
			
			// Process infrastructure data if available
			processInfrastructureData(data);
		}
		}

		// Global variables to track current sort mode and order
		let currentCrimeSortMode = 'severity'; // 'severity' or 'value'
		let currentCrimeSortOrder = 'desc'; // 'desc' or 'asc'
		
		// Global variables to track search parameters
		let searchCenter = null; // { lat, lon }
		let searchRadiusKm = null;
		
		// Haversine formula to calculate distance between two coordinates
		function haversine(lat1, lon1, lat2, lon2) {
			const R = 6371; // Earth's radius in kilometers
			const dLat = (lat2 - lat1) * Math.PI / 180;
			const dLon = (lon2 - lon1) * Math.PI / 180;
			const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
					  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
					  Math.sin(dLon/2) * Math.sin(dLon/2);
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
			return R * c; // Distance in kilometers
		}

		// Function to process and visualize crime data
		// Note: This uses municipality-wide crime data (muni_stats) because crime data doesn't specify zip codes
		// Population data for crime normalization is also municipality-wide to match crime data scope
		function processCrimeData(data) {
			const crimeVisualization = document.getElementById('crimeVisualization');
			const sortControls = document.getElementById('crimeSortControls');
			
			// Check if crime data exists in the response
			if (!data || !data.data || !data.data.muni_stats || !data.data.muni_stats.rows) {
				crimeVisualization.innerHTML = '<div class="placeholder">No crime data available in API response</div>';
				if (sortControls) sortControls.style.display = 'none';
				return;
			}

			// Show sort controls when crime data is available
			if (sortControls) {
				sortControls.style.display = 'block';
				updateSortButtonText();
				updateOrderButtonText();
			}

			const allRows = data.data.muni_stats.rows;
			console.log('All muni_stats data found:', allRows);

			// Filter for crime-related indicators only
			const crimeRows = allRows.filter(row => {
				const indicatorName = row.indicator_name.toLowerCase();
				// Only include indicators that are likely crime-related
				return indicatorName.includes('homicide') || 
					   indicatorName.includes('murder') || 
					   indicatorName.includes('sexual') || 
					   indicatorName.includes('assault') || 
					   indicatorName.includes('rape') || 
					   indicatorName.includes('kidnapping') || 
					   indicatorName.includes('robbery') || 
					   indicatorName.includes('theft') || 
					   indicatorName.includes('burglary') || 
					   indicatorName.includes('fraud') || 
					   indicatorName.includes('drug') || 
					   indicatorName.includes('violence') || 
					   indicatorName.includes('crime') ||
					   indicatorName.includes('offence') ||
					   indicatorName.includes('offense');
			});

			console.log('Filtered crime data:', crimeRows);

			if (crimeRows.length === 0) {
				crimeVisualization.innerHTML = '<div class="placeholder">No crime-related indicators found in API response</div>';
				if (sortControls) sortControls.style.display = 'none';
				return;
			}

			// Crime categories ranked by severity (1 = most serious, 13 = least serious)
			// Only the categories provided by the user are included
			const crimeCategories = [
				{ rank: 1, name: "Homicide & murder (completed)", color: "#8B0000", keywords: ["homicide", "murder", "completed"] },
				{ rank: 2, name: "Homicide & murder (attempted)", color: "#A40000", keywords: ["homicide", "murder", "attempted"] },
				{ rank: 3, name: "Sexual assault with penetration", color: "#B22222", keywords: ["sexual assault", "penetration", "rape"] },
				{ rank: 4, name: "Kidnapping", color: "#C72C1C", keywords: ["kidnapping"] },
				{ rank: 5, name: "Robbery with violence/intimidation", color: "#D43C00", keywords: ["robbery", "violence", "intimidation"] },
				{ rank: 6, name: "Serious/less serious injury & mass brawls", color: "#E05206", keywords: ["serious injury", "less serious injury", "mass brawls", "riots", "injury"] },
				{ rank: 7, name: "Drug trafficking", color: "#E66B0A", keywords: ["drug trafficking", "drug"] },
				{ rank: 8, name: "Residential burglaries", color: "#EC820E", keywords: ["residential burglaries", "burglary", "residential"] },
				{ rank: 9, name: "Vehicle theft", color: "#F09719", keywords: ["vehicle theft", "vehicle"] },
				{ rank: 10, name: "Thefts", color: "#F4A41C", keywords: ["thefts", "theft"] },
				{ rank: 11, name: "Other sexual offences", color: "#F6B828", keywords: ["other sexual", "sexual offences", "sexual offenses"] },
				{ rank: 12, name: "Other conventional crime", color: "#F8CA3E", keywords: ["other conventional", "conventional crime"] },
				{ rank: 13, name: "Cybercrime", color: "#FFDD57", keywords: ["cybercrime", "cyber", "it fraud", "fraud"] }
			];

			// Helper function to match indicator name to crime category
			function matchIndicatorToCategory(indicatorName) {
				const lowerName = indicatorName.toLowerCase();
				let bestMatch = null;
				let bestMatchCount = 0;
				
				// Try exact match first
				for (const category of crimeCategories) {
					if (category.name.toLowerCase() === lowerName) {
						return category;
					}
				}
				
				// Try keyword matching - find the category with the most matching keywords
				for (const category of crimeCategories) {
					const matches = category.keywords.filter(keyword => {
						const lowerKeyword = keyword.toLowerCase();
						return lowerName.includes(lowerKeyword);
					});
					
					if (matches.length > bestMatchCount) {
						bestMatchCount = matches.length;
						bestMatch = category;
					}
				}
				
				// Only return a match if at least one keyword matched
				return bestMatchCount > 0 ? bestMatch : null;
			}
			
			// Extract and categorize crime data
			// Only include categories that match the user's provided categories
			const crimeData = crimeRows
				.map(row => {
					const value = parseInt(row.value) || 0;
					const indicatorName = row.indicator_name;
					
					// Find matching category
					const match = matchIndicatorToCategory(indicatorName);
					
					if (match) {
						const category = match.category || match;
						return {
							indicator: category.name, // Use standardized category name
							value: value,
							color: category.color,
							rank: category.rank, // Severity rank (1-13)
							originalName: indicatorName // Keep original for reference
						};
					}
					
					// If no match found, exclude this indicator (only keep user-provided categories)
					return null;
				})
				.filter(item => item !== null) // Remove unmatched items
				.sort((a, b) => {
					let result = 0;
					
					if (currentCrimeSortMode === 'severity') {
						// Sort by rank (1 = most serious, 13 = least serious)
						result = a.rank - b.rank;
						
						// If same rank, sort by value
						if (result === 0) {
							result = b.value - a.value; // Higher value first
						}
					} else {
						// Sort by value only
						result = b.value - a.value;
					}
					
					// Apply sort order (ascending/descending)
					return currentCrimeSortOrder === 'asc' ? -result : result;
				});
			
			// Remove duplicates by category (keep the first occurrence)
			const uniqueCrimeData = [];
			const seenCategories = new Set();
			for (const crime of crimeData) {
				if (!seenCategories.has(crime.indicator)) {
					seenCategories.add(crime.indicator);
					uniqueCrimeData.push(crime);
				}
			}

			if (uniqueCrimeData.length === 0) {
				crimeVisualization.innerHTML = '<div class="placeholder">No crime data matching the provided categories found in API response</div>';
				if (sortControls) sortControls.style.display = 'none';
				return;
			}

			// Create visualizations (use uniqueCrimeData)
			const finalCrimeData = uniqueCrimeData;
			crimeVisualization.innerHTML = `
				<!-- Safety Index KPI -->
				<div style="margin-bottom: 20px; text-align: center; padding: 16px; background: #f8f9fa; border-radius: 8px;">
					<h3 style="margin: 0 0 4px 0; font-size: 16px; color: #6b7280;">Safety Index</h3>
					<p style="margin: 0 0 8px 0; font-size: 11px; color: #9ca3af; font-style: italic;">Municipality crime data vs municipality population</p>
					<div id="safetyIndexValue" style="font-size: 2.5em; font-weight: bold; color: #488E98; margin: 0;">-</div>
					<div id="safetyIndexDetails" style="font-size: 12px; color: #6b7280; margin-top: 4px;">Calculating...</div>
				</div>
				
				<div style="margin-bottom: 20px;">
					<h4 style="margin: 0 0 10px 0; color: #488E98;">Crime offences in ${data.place || 'Search Area'} (2025Q1)</h4>
					<div style="display: flex; gap: 20px; flex-wrap: wrap;">
						<div style="flex: 1; min-width: 300px;">
							<h5 style="margin: 0 0 10px 0;">Color-Coded Bar Chart (All Crime Types)</h5>
							<div id="colorBarChart" style="height: 500px; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: #fff; overflow-y: auto;"></div>
						</div>
						<div style="flex: 1; min-width: 300px;">
							<h5 style="margin: 0 0 10px 0;">Crime Distribution</h5>
							<div style="border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: #fff; height: 500px; display: flex; align-items: center; justify-content: center;">
								<canvas id="crimeDonutChart" style="max-width: 100%; max-height: 100%;"></canvas>
							</div>
						</div>
					</div>
				</div>
			`;

			// Calculate and display Safety Index
			calculateSafetyIndex(finalCrimeData, data);
			
			// Create color-coded bar chart
			createColorBarChart(finalCrimeData);
			
			// Create donut chart
			createCrimeDonutChart(finalCrimeData);
		}

		// Function to create color-coded bar chart
		function createColorBarChart(crimeData) {
			const barChartContainer = document.getElementById('colorBarChart');
			const maxValue = Math.max(...crimeData.map(d => d.value));
			
			barChartContainer.innerHTML = crimeData.map(item => {
				const barWidth = (item.value / maxValue) * 100;
				return `
					<div style="margin-bottom: 8px;">
						<div style="display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 12px;">
							<span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 10px;">${item.indicator}</span>
							<span style="font-weight: bold; color: #374151;">${item.value}</span>
						</div>
						<div style="background: #e5e7eb; height: 20px; border-radius: 10px; overflow: hidden;">
							<div style="background: ${item.color}; height: 100%; width: ${barWidth}%; transition: width 0.3s ease;"></div>
						</div>
					</div>
				`;
			}).join('');
		}

		// Function to create crime donut chart
		function createCrimeDonutChart(crimeData) {
			const ctx = document.getElementById('crimeDonutChart');
			
			if (!ctx) {
				console.log('Crime donut chart canvas not found');
				return;
			}
			
			// Destroy existing chart if it exists
			if (window.crimeDonutChartInstance) {
				window.crimeDonutChartInstance.destroy();
			}
			
			// Prepare data for donut chart
			const chartData = {
				labels: crimeData.map(item => item.indicator),
				datasets: [{
					data: crimeData.map(item => item.value),
					backgroundColor: crimeData.map(item => item.color),
					borderColor: crimeData.map(item => item.color),
					borderWidth: 2,
					hoverBorderWidth: 3
				}]
			};
			
			const config = {
				type: 'doughnut',
				data: chartData,
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							position: 'bottom',
							labels: {
								padding: 10,
								usePointStyle: true,
								font: {
									size: 11
								}
							}
						},
						title: {
							display: true,
							text: 'Crime Distribution by Type',
							font: {
								size: 14,
								weight: 'bold'
							}
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const label = context.label || '';
									const value = context.parsed;
									const total = context.dataset.data.reduce((a, b) => a + b, 0);
									const percentage = ((value / total) * 100).toFixed(1);
									return `${label}: ${value.toLocaleString()} (${percentage}%)`;
								}
							}
						}
					},
					cutout: '60%', // Makes it a donut chart
					animation: {
						animateRotate: true,
						animateScale: true
					}
				}
			};
			
			// Create new chart
			window.crimeDonutChartInstance = new Chart(ctx, config);
		}

		// Function to calculate Safety Index
		// Uses: Population (POP_TOTAL from Munistats), Crime counts (value), Severity (rank 1-13)
		function calculateSafetyIndex(crimeData, apiData) {
			try {
				console.log('[Safety Index] Starting calculation...');
				console.log('[Safety Index] Crime data count:', crimeData ? crimeData.length : 0);
				
				// Validate crime data
				if (!crimeData || crimeData.length === 0) {
					updateSafetyIndexDisplay(-1, "No crime data available to calculate safety index");
					console.error('[Safety Index] ‚ùå No crime data provided');
					return;
				}
				
				// Get population from Munistats data (POP_TOTAL)
				const population = getPopulationFromData(apiData);
				
				if (!population || population <= 0) {
					updateSafetyIndexDisplay(-1, `Population data not available (POP_TOTAL not found in Munistats)`);
					console.error('[Safety Index] ‚ùå Population data missing');
					return;
				}
				
				console.log('[Safety Index] ‚úÖ Population found:', population);
				
				// NEW SIMPLIFIED FORMULA
				// Data we have:
				// 1. Total Population (from POP_TOTAL in Munistats)
				// 2. 13 crime types with ranks 1-13 (1 = most serious, 13 = least serious)
				// 3. Crime counts (value) for each type
				
				console.log('[Safety Index] Processing crime data:', crimeData.length, 'crimes');
				console.log('[Safety Index] Sample crime data:', crimeData.slice(0, 3));
				
				// Step 1: Calculate weighted crime score
				// Weight = 14 - rank (so rank 1 gets weight 13, rank 13 gets weight 1)
				let weightedCrimeScore = 0;
				let totalCrimes = 0;
				const crimeBreakdown = {
					high: { count: 0 },
					medium: { count: 0 },
					mediumLow: { count: 0 },
					low: { count: 0 }
				};
				
				crimeData.forEach(crime => {
					if (!crime || typeof crime.rank === 'undefined' || typeof crime.value === 'undefined') {
						console.warn('[Safety Index] Invalid crime data:', crime);
						return;
					}
					
					const crimeValue = parseInt(crime.value) || 0;
					const weight = 14 - crime.rank; // Rank 1 ‚Üí weight 13, Rank 13 ‚Üí weight 1
					const weightedValue = crimeValue * weight;
					
					weightedCrimeScore += weightedValue;
					totalCrimes += crimeValue;
					
					// Categorize for breakdown
					if (crime.rank <= 3) crimeBreakdown.high.count += crimeValue;
					else if (crime.rank <= 6) crimeBreakdown.medium.count += crimeValue;
					else if (crime.rank <= 9) crimeBreakdown.mediumLow.count += crimeValue;
					else crimeBreakdown.low.count += crimeValue;
					
					console.log(`[Safety Index] ${crime.indicator}: Count=${crimeValue}, Rank=${crime.rank}, Weight=${weight}, Weighted=${weightedValue}`);
				});
				
				if (weightedCrimeScore === 0 || totalCrimes === 0) {
					updateSafetyIndexDisplay(-1, "No valid crime data found");
					return;
				}
				
				// Step 2: Calculate crime rate per 100,000 residents
				// Using total population from POP_TOTAL
				const weightedCrimeRate = (weightedCrimeScore / population) * 100000;
				const totalCrimeRate = (totalCrimes / population) * 100000;
				
				console.log('[Safety Index] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
				console.log('[Safety Index] FORMULA INPUTS:');
				console.log('[Safety Index] - Total Population:', population.toLocaleString());
				console.log('[Safety Index] - Total Crime Count:', totalCrimes);
				console.log('[Safety Index] - Weighted Crime Score:', weightedCrimeScore);
				console.log('[Safety Index] - Total Crime Rate per 100k:', totalCrimeRate.toFixed(2));
				console.log('[Safety Index] - Weighted Crime Rate per 100k:', weightedCrimeRate.toFixed(2));
				
				// Step 3: Calculate Safety Index
				// Formula: Safety Index = 100 √ó (1 - weightedCrimeRate / theoretical_max_weighted_rate)
				// We need a reasonable theoretical maximum to scale against
				// If we assume worst case: all crimes are rank 1 (most serious), the max weighted rate would be:
				// theoretical_max = (totalCrimes √ó 13) / population √ó 100000
				// But for a more practical scale, let's use a percentile-based approach
				
				// Alternative: Use actual max weighted rate from data or a fixed reasonable maximum
				// For now, let's calculate what the max weighted rate would be if all crimes were rank 1
				const theoreticalMaxWeightedRate = (totalCrimes * 13 / population) * 100000;
				
				// But we need a more stable reference. Let's use a fixed reference point:
				// Reference: What would be a "very high crime rate" in weighted terms?
				// If total crime rate is 5000 per 100k, and all crimes are rank 1 (weight 13):
				// weighted rate = 5000 √ó 13 = 65,000 per 100k
				// So let's use a max reference of 50,000 weighted crimes per 100k as "worst case"
				const maxReferenceWeightedRate = 50000; // Represents very high crime scenario
				
				// Safety Index = 100 √ó (1 - weightedRate / maxReference)
				// This gives: 0% safety when weighted rate = maxReference, 100% when weighted rate = 0
				let safetyIndex = 100 * (1 - weightedCrimeRate / maxReferenceWeightedRate);
				
				// Clamp between 0 and 100
				safetyIndex = Math.max(0, Math.min(100, safetyIndex));
				
				console.log('[Safety Index] CALCULATION:');
				console.log('[Safety Index] - Max Reference (worst case):', maxReferenceWeightedRate, 'weighted crimes per 100k');
				console.log('[Safety Index] - Current Weighted Rate:', weightedCrimeRate.toFixed(2), 'per 100k');
				console.log('[Safety Index] - Ratio:', (weightedCrimeRate / maxReferenceWeightedRate).toFixed(4));
				console.log('[Safety Index] - Safety Index:', safetyIndex.toFixed(2));
				console.log('[Safety Index] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
				
				// If weighted crime rate is too high, warn about it
				if (weightedCrimeRate > maxReferenceWeightedRate) {
					console.warn('[Safety Index] ‚ö†Ô∏è Weighted crime rate exceeds max reference!');
					console.warn('[Safety Index] ‚ö†Ô∏è Weighted Rate:', weightedCrimeRate.toFixed(2), 'vs Max Reference:', maxReferenceWeightedRate);
				}
				
				// Update display
				// IMPORTANT: Use weightedCrimeRate for the calculation, but show it in details
				console.log('[Safety Index] About to update display with:');
				console.log('[Safety Index] - safetyIndex:', safetyIndex);
				console.log('[Safety Index] - weightedCrimeRate:', weightedCrimeRate);
				console.log('[Safety Index] - totalCrimeRate:', totalCrimeRate);
				
				updateSafetyIndexDisplay(safetyIndex, {
					weightedCrimeRate: weightedCrimeRate,
					totalCrimeRate: totalCrimeRate,
					population: population,
					breakdown: crimeBreakdown
				});
				
			} catch (error) {
				console.error('[Safety Index] ‚ùå Error calculating Safety Index:', error);
				console.error('[Safety Index] Error name:', error.name);
				console.error('[Safety Index] Error message:', error.message);
				console.error('[Safety Index] Error stack:', error.stack);
				updateSafetyIndexDisplay(-1, `Error calculating safety index: ${error.message}`);
			}
		}
		
		// Helper function to get population from API data for crime calculations
		// Gets POP_TOTAL from Munistats data (Indicator Code = POP_TOTAL)
		function getPopulationFromData(apiData) {
			try {
				console.log('[Safety Index] Looking for POP_TOTAL from Munistats data...');
				
				// Look for POP_TOTAL from municipality data (muni_stats)
				if (apiData && apiData.data && apiData.data.muni_stats && apiData.data.muni_stats.rows) {
					const allRows = apiData.data.muni_stats.rows;
					console.log('[Safety Index] Total muni_stats rows:', allRows.length);
					
					// First, try exact match: indicator_code = 'POP_TOTAL'
					let popTotalRow = allRows.find(row => row.indicator_code === 'POP_TOTAL');
					
					if (popTotalRow && popTotalRow.value) {
						const population = parseFloat(popTotalRow.value);
						console.log(`[Safety Index] ‚úÖ Found POP_TOTAL: ${population}`);
						console.log('[Safety Index] POP_TOTAL row details:', {
							indicator_code: popTotalRow.indicator_code,
							indicator_name: popTotalRow.indicator_name,
							value: popTotalRow.value,
							area_type: popTotalRow.municipio_area_type_name
						});
						return population;
					}
					
					// If not found, try with municipio_area_type_name filter
					popTotalRow = allRows.find(row => 
						row.indicator_code === 'POP_TOTAL' && 
						row.municipio_area_type_name === 'Municipio'
					);
					
					if (popTotalRow && popTotalRow.value) {
						const population = parseFloat(popTotalRow.value);
						console.log(`[Safety Index] ‚úÖ Found POP_TOTAL (Municipio): ${population}`);
						return population;
					}
					
					// Log all indicator codes for debugging
					const indicatorCodes = [...new Set(allRows.map(r => r.indicator_code))];
					console.log('[Safety Index] Available indicator codes:', indicatorCodes);
					console.log('[Safety Index] ‚ö†Ô∏è POP_TOTAL not found in muni_stats');
					
					// Fallback: sum age-based indicators if POP_TOTAL not found
					const ageIndicators = [
						'POP_0_4', 'POP_5_9', 'POP_10_14', 'POP_15_19', 'POP_20_24', 'POP_25_29', 'POP_30_34', 'POP_35_39',
						'POP_40_44', 'POP_45_49', 'POP_50_54', 'POP_55_59', 'POP_60_64', 'POP_65_69', 'POP_70_74',
						'POP_75_79', 'POP_80_84', 'POP_85_89', 'POP_90_94', 'POP_95_99', 'POP_100_PLUS'
					];
					
					let totalPopulation = 0;
					for (const indicator of ageIndicators) {
						const ageRow = allRows.find(row => row.indicator_code === indicator);
						if (ageRow && ageRow.value) {
							totalPopulation += parseFloat(ageRow.value);
						}
					}
					
					if (totalPopulation > 0) {
						console.log(`[Safety Index] ‚úÖ Calculated population from age indicators: ${totalPopulation}`);
						return totalPopulation;
					}
				}
				
				console.error('[Safety Index] ‚ùå No population data found in muni_stats');
				return null;
			} catch (error) {
				console.error('[Safety Index] ‚ùå Error getting population data:', error);
				return null;
			}
		}
		
		// Function to update Safety Index display
		function updateSafetyIndexDisplay(safetyIndex, details) {
			const safetyIndexValue = document.getElementById('safetyIndexValue');
			const safetyIndexDetails = document.getElementById('safetyIndexDetails');
			
			if (!safetyIndexValue || !safetyIndexDetails) {
				console.log('Safety Index display elements not found');
				return;
			}
			
			if (safetyIndex < 0) {
				safetyIndexValue.textContent = 'Unable to Calculate';
				safetyIndexValue.style.color = '#6b7280';
				safetyIndexDetails.textContent = details;
				return;
			}
			
			// Get safety level and color based on safety index
			let safetyLevel, color, description;
			
			if (safetyIndex >= 80) {
				safetyLevel = 'Very Safe';
				color = '#16a34a'; // Green
				description = 'Low crime area with excellent safety';
			} else if (safetyIndex >= 60) {
				safetyLevel = 'Safe';
				color = '#22c55e'; // Light green
				description = 'Good safety with moderate crime levels';
			} else if (safetyIndex >= 40) {
				safetyLevel = 'Moderate';
				color = '#ca8a04'; // Yellow
				description = 'Average safety with some crime concerns';
			} else if (safetyIndex >= 20) {
				safetyLevel = 'Caution';
				color = '#ea580c'; // Orange
				description = 'Higher crime area, exercise caution';
			} else {
				safetyLevel = 'High Risk';
				color = '#dc2626'; // Red
				description = 'High crime area, significant safety concerns';
			}
			
			safetyIndexValue.textContent = `${safetyLevel} (${Math.round(safetyIndex)})`;
			safetyIndexValue.style.color = color;
			
			// Update details with description
			if (typeof details === 'object') {
				const weightedRate = details.weightedCrimeRate.toFixed(1);
				const totalRate = details.totalCrimeRate.toFixed(1);
				safetyIndexDetails.innerHTML = `
					${description} | 
					Municipality Crime Rate: ${totalRate} per 100k | 
					Municipality Population: ${details.population.toLocaleString()}
				`;
			} else {
				safetyIndexDetails.textContent = details;
			}
		}

		// Helper function to convert hex to RGB
		function hexToRgb(hex) {
			const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
			return result ? 
				parseInt(result[1], 16) + ',' + 
				parseInt(result[2], 16) + ',' + 
				parseInt(result[3], 16) : 
				'0,0,0';
		}

		// Function to toggle crime sort mode
		function toggleCrimeSort() {
			currentCrimeSortMode = currentCrimeSortMode === 'severity' ? 'value' : 'severity';
			updateSortButtonText();
			
			// Re-process the last API response with new sort mode
			if (window.lastApiResponse) {
				processCrimeData(window.lastApiResponse);
			}
		}

		// Function to toggle crime sort order
		function toggleCrimeOrder() {
			currentCrimeSortOrder = currentCrimeSortOrder === 'desc' ? 'asc' : 'desc';
			updateOrderButtonText();
			
			// Re-process the last API response with new sort order
			if (window.lastApiResponse) {
				processCrimeData(window.lastApiResponse);
			}
		}

		// Function to update sort button text
		function updateSortButtonText() {
			const sortButton = document.getElementById('crimeSortButton');
			if (sortButton) {
				sortButton.textContent = `Sort by: ${currentCrimeSortMode === 'severity' ? 'Severity' : 'Value'}`;
			}
		}

		// Function to update order button text
		function updateOrderButtonText() {
			const orderButton = document.getElementById('crimeOrderButton');
			if (orderButton) {
				const arrow = currentCrimeSortOrder === 'desc' ? '‚Üì' : '‚Üë';
				const text = currentCrimeSortOrder === 'desc' ? 'Desc' : 'Asc';
				orderButton.textContent = `${arrow} ${text}`;
			}
		}

		// Global variables for pagination
		let allPropertyData = [];
		let originalPropertyData = []; // Store original unfiltered data
		let currentPage = 1;
		const itemsPerPage = 25;
		
		// Global variables for filters
		let filterState = {
			minPrice: null,
			maxPrice: null,
			minSize: null,
			maxSize: null,
			minRooms: null,
			maxRooms: null,
			features: [] // Array of selected features: ['balcony', 'parking', etc.]
		};
		
		// Track current sort option
		let currentSortOption = null;

		// Function to process and display property listings
		function processPropertyListings(data) {
			const listingsContainer = document.getElementById('listingsContainer') || document.querySelector('.listings');
			
			// Don't override if currently in map view
			if (isMapView) {
				console.log('Currently in map view, skipping property list update');
				return;
			}
			
			// Check if property data exists in the response
			if (!data || !data.data || !data.data.properties || !data.data.properties.rows) {
				if (listingsContainer) {
					listingsContainer.innerHTML = '<div class="placeholder">No property listings available in API response</div>';
				}
				hidePagination();
				return;
			}

			const propertyRows = data.data.properties.rows;
			console.log('Property data found:', propertyRows);

			if (propertyRows.length === 0) {
				if (listingsContainer) {
					listingsContainer.innerHTML = '<div class="placeholder">No properties found matching your criteria</div>';
				}
				hidePagination();
				return;
			}

			// Store all property data globally (original unfiltered data)
			originalPropertyData = propertyRows;
			allPropertyData = [...propertyRows]; // Working copy
			currentPage = 1; // Reset to first page

			// Apply any existing filters
			applyFilters();
			
			// Update results count display
			updateResultsCountDisplay();

			// Render the first page
			renderPropertyPage(1);
		}

		// Function to render a specific page of properties
		function renderPropertyPage(page) {
			const listingsContainer = document.getElementById('listingsContainer') || document.querySelector('.listings');
			const paginationContainer = document.getElementById('paginationContainer');
			
			if (!listingsContainer) {
				return;
			}
			
			// Update results count even if no data
			updateResultsCountDisplay();
			
			if (!allPropertyData.length) {
				return;
			}

			// Calculate pagination
			const totalItems = allPropertyData.length;
			const totalPages = Math.ceil(totalItems / itemsPerPage);
			const startIndex = (page - 1) * itemsPerPage;
			const endIndex = Math.min(startIndex + itemsPerPage, totalItems);
			const currentPageData = allPropertyData.slice(startIndex, endIndex);

			// Generate property cards for current page
			const propertyCards = currentPageData.map((property, index) => {
				const globalIndex = startIndex + index; // Global index for compare IDs
				
				// Format price
				const price = property.price_amount ? 
					`‚Ç¨${property.price_amount.toLocaleString()}` : 
					'Price not available';

				// Build meta line (sqm ‚Ä¢ rooms)
				const metaParts = [];
				if (property.sqm) metaParts.push(`${property.sqm} m¬≤`);
				if (property.rooms) metaParts.push(`${property.rooms} rm`);
				const metaLine = metaParts.length > 0 ? metaParts.join(' ‚Ä¢ ') : '';

				// Build condition badges
				const badges = [];
				if (property.good_condition === true) {
					badges.push('<span class="badge">Good condition</span>');
				}
				if (property.needs_renovation === true) {
					badges.push('<span class="badge warn">Needs renovation</span>');
				}

				// Build location and original listing link
				const location = property.location_optimized || 'Location not available';
				const originalListingLink = property.url ? 
					`<a class="small" href="${property.url}" target="_blank">Original listing</a>` : 
					'<span class="small">Original listing not available</span>';

				return `
					<div class="property-card">
						<div class="property-thumb"></div>
						<div>
							<div style="display:flex; align-items:center; gap:8px; justify-content:space-between;">
								<strong>${price}</strong>
								<label class="small"><input type="checkbox" data-compare-id="p${globalIndex + 1}" /> Compare</label>
							</div>
							${badges.length > 0 ? `<div class="badges">${badges.join('')}</div>` : ''}
							${metaLine ? `<div class="property-meta"><span>${metaLine}</span></div>` : ''}
							<div>${location} ‚Ä¢ ${originalListingLink}</div>
							<a class="small" href="property.html">View details</a>
						</div>
					</div>
				`;
			}).join('');

			// Update the listings container
			listingsContainer.innerHTML = propertyCards;

			// Store the content for toggle functionality (only if not in map view)
			if (!isMapView) {
				originalListingsContent = propertyCards;
			}

			// Update results count display
			updateResultsCountDisplay();

			// Update pagination controls with filtered/total count
			updatePaginationControls(page, totalPages, totalItems, startIndex, endIndex, originalPropertyData.length);

			// Show pagination if there are multiple pages
			if (totalPages > 1) {
				paginationContainer.style.display = 'block';
			} else {
				paginationContainer.style.display = 'none';
			}

			console.log(`Rendered page ${page} of ${totalPages} (items ${startIndex + 1}-${endIndex} of ${totalItems})`);
		}

		// Function to update pagination controls
		function updatePaginationControls(currentPage, totalPages, totalItems, startIndex, endIndex, totalUnfiltered) {
			const paginationControls = document.getElementById('paginationControls');
			const paginationInfo = document.getElementById('paginationInfo');

			if (!paginationControls || !paginationInfo) {
				return;
			}
			
			// Build pagination info text
			let infoText = `Showing ${startIndex + 1}-${endIndex} of ${totalItems}`;
			
			// If filters are active and we have unfiltered count, show both filtered and total
			if (totalUnfiltered !== undefined && totalUnfiltered > 0 && totalItems !== totalUnfiltered) {
				infoText = `Showing ${startIndex + 1}-${endIndex} of ${totalItems} (filtered from ${totalUnfiltered} total)`;
			}
			
			paginationInfo.textContent = infoText;

			// Clear existing controls
			paginationControls.innerHTML = '';

			// Previous button
			const prevButton = document.createElement('button');
			prevButton.className = 'pagination-btn';
			prevButton.textContent = '‚Üê Previous';
			prevButton.disabled = currentPage === 1;
			prevButton.onclick = () => changePage(currentPage - 1);
			paginationControls.appendChild(prevButton);

			// Page numbers
			const maxVisiblePages = 5;
			let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
			let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

			// Adjust start page if we're near the end
			if (endPage - startPage + 1 < maxVisiblePages) {
				startPage = Math.max(1, endPage - maxVisiblePages + 1);
			}

			// First page and ellipsis
			if (startPage > 1) {
				const firstButton = document.createElement('button');
				firstButton.className = 'pagination-btn';
				firstButton.textContent = '1';
				firstButton.onclick = () => changePage(1);
				paginationControls.appendChild(firstButton);

				if (startPage > 2) {
					const ellipsis = document.createElement('span');
					ellipsis.textContent = '...';
					ellipsis.style.padding = '6px 8px';
					ellipsis.style.color = '#6b7280';
					paginationControls.appendChild(ellipsis);
				}
			}

			// Page number buttons
			for (let i = startPage; i <= endPage; i++) {
				const pageButton = document.createElement('button');
				pageButton.className = `pagination-btn ${i === currentPage ? 'active' : ''}`;
				pageButton.textContent = i.toString();
				pageButton.onclick = () => changePage(i);
				paginationControls.appendChild(pageButton);
			}

			// Last page and ellipsis
			if (endPage < totalPages) {
				if (endPage < totalPages - 1) {
					const ellipsis = document.createElement('span');
					ellipsis.textContent = '...';
					ellipsis.style.padding = '6px 8px';
					ellipsis.style.color = '#6b7280';
					paginationControls.appendChild(ellipsis);
				}

				const lastButton = document.createElement('button');
				lastButton.className = 'pagination-btn';
				lastButton.textContent = totalPages.toString();
				lastButton.onclick = () => changePage(totalPages);
				paginationControls.appendChild(lastButton);
			}

			// Next button
			const nextButton = document.createElement('button');
			nextButton.className = 'pagination-btn';
			nextButton.textContent = 'Next ‚Üí';
			nextButton.disabled = currentPage === totalPages;
			nextButton.onclick = () => changePage(currentPage + 1);
			paginationControls.appendChild(nextButton);

			// Update pagination info
			paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${totalItems} properties`;
		}

		// Function to change page
		function changePage(newPage) {
			if (newPage < 1 || newPage > Math.ceil(allPropertyData.length / itemsPerPage)) {
				return;
			}
			currentPage = newPage;
			renderPropertyPage(newPage);
		}

		// Function to hide pagination
		function hidePagination() {
			const paginationContainer = document.getElementById('paginationContainer');
			if (paginationContainer) {
				paginationContainer.style.display = 'none';
			}
		}

		// Function to handle property details view
		function viewProperty(propertyId) {
			console.log('Viewing property:', propertyId);
			alert(`Viewing property details for ID: ${propertyId}`);
			// TODO: Navigate to property detail page or show modal
		}

		// Global variable to track view mode
		let isMapView = false;

		// Function to process market analytics data
		function processMarketAnalytics(data) {
			const marketContainer = document.getElementById('marketAnalyticsContainer');
			const placeholder = document.getElementById('marketAnalyticsPlaceholder');
			
			// Check if property data exists
			if (!data || !data.data || !data.data.properties || !data.data.properties.rows) {
				if (marketContainer) marketContainer.style.display = 'none';
				if (placeholder) placeholder.style.display = 'block';
				return;
			}

			const properties = data.data.properties.rows;
			console.log('Processing market analytics for', properties.length, 'properties');

			if (properties.length === 0) {
				if (marketContainer) marketContainer.style.display = 'none';
				if (placeholder) placeholder.style.display = 'block';
				return;
			}

			// Show market analytics container
			if (marketContainer) marketContainer.style.display = 'block';
			if (placeholder) placeholder.style.display = 'none';

			// Calculate market metrics
			const marketMetrics = calculateMarketMetrics(properties);
			
			// Update KPI displays
			updateMarketKPIs(marketMetrics);
			
			// Render charts
			renderPriceDistributionChart(properties);
			renderPriceSizeScatterChart(properties);
			
			// Generate market summary
			generateMarketSummary(marketMetrics, properties);
		}

		// Function to calculate market metrics
		function calculateMarketMetrics(properties) {
			// Filter properties with valid price and size data
			const validProperties = properties.filter(p => 
				p.price_amount && p.price_amount > 0 && 
				p.sqm && p.sqm > 0
			);

			if (validProperties.length === 0) {
				return {
					avgPrice: 0,
					medianPrice: 0,
					listingsCount: properties.length,
					medianSize: 0,
					avgPricePerSqm: 0,
					priceRange: { min: 0, max: 0 },
					sizeRange: { min: 0, max: 0 }
				};
			}

			// Sort prices for median calculation
			const prices = validProperties.map(p => p.price_amount).sort((a, b) => a - b);
			const sizes = validProperties.map(p => p.sqm).sort((a, b) => a - b);
			const pricesPerSqm = validProperties.map(p => p.price_per_sqm || (p.price_amount / p.sqm));

			return {
				avgPrice: prices.reduce((sum, price) => sum + price, 0) / prices.length,
				medianPrice: prices[Math.floor(prices.length / 2)],
				listingsCount: properties.length,
				medianSize: sizes[Math.floor(sizes.length / 2)],
				avgPricePerSqm: pricesPerSqm.reduce((sum, price) => sum + price, 0) / pricesPerSqm.length,
				priceRange: { min: Math.min(...prices), max: Math.max(...prices) },
				sizeRange: { min: Math.min(...sizes), max: Math.max(...sizes) },
				validProperties: validProperties
			};
		}

		// Function to update market KPIs
		function updateMarketKPIs(metrics) {
			document.getElementById('avgPrice').textContent = `‚Ç¨${Math.round(metrics.avgPrice).toLocaleString()}`;
			document.getElementById('medianPrice').textContent = `‚Ç¨${Math.round(metrics.medianPrice).toLocaleString()}`;
			document.getElementById('listingsCount').textContent = metrics.listingsCount.toLocaleString();
			document.getElementById('medianSize').textContent = `${Math.round(metrics.medianSize)} m¬≤`;
			document.getElementById('avgPricePerSqm').textContent = `‚Ç¨${Math.round(metrics.avgPricePerSqm).toLocaleString()}`;
		}

		// Function to render price distribution chart
		function renderPriceDistributionChart(properties) {
			const container = document.getElementById('priceDistributionChart');
			if (!container) return;

			// Clear existing content
			container.innerHTML = '';

			// Filter properties with valid prices
			const validProperties = properties.filter(p => p.price_amount && p.price_amount > 0);
			if (validProperties.length === 0) {
				container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No price data available</div>';
				return;
			}

			const prices = validProperties.map(p => p.price_amount);

			// Fixed price categories as requested
			const priceCategories = [
				150000,    // <150K
				250000,    // <250K
				500000,    // <500K
				1000000,   // <1M
				5000000,   // <5M
				10000000,  // <10M
				30000000   // <30M
			];

			const numBins = priceCategories.length;
			const bins = Array(numBins).fill(0);
			const binProperties = Array(numBins).fill(null).map(() => []); // Store properties in each bin for size calculations
			const binLabels = [];
			const binRanges = [];

			// Helper function for formatting prices
			const formatPrice = (price) => {
				if (price >= 1000000) {
					return `${(price / 1000000).toFixed(1)}M`;
				} else if (price >= 1000) {
					return `${Math.round(price / 1000)}k`;
				}
				return `${Math.round(price)}`;
			};

			// Create bin labels and ranges
			for (let i = 0; i < numBins; i++) {
				const upperBound = priceCategories[i];
				const lowerBound = i === 0 ? 0 : priceCategories[i - 1];
				binRanges.push({ start: lowerBound, end: upperBound });
				binLabels.push(`<${formatPrice(upperBound)}`);
			}

			// Count properties in each bin and store properties for size calculations
			validProperties.forEach(property => {
				const price = property.price_amount;
				// Check each bin in order
				for (let i = 0; i < numBins; i++) {
					const upperBound = priceCategories[i];
					const lowerBound = i === 0 ? 0 : priceCategories[i - 1];
					
					// For the last bin: include everything >= upperBound (30M+)
					if (i === numBins - 1) {
						if (price >= upperBound) {
							bins[i]++;
							binProperties[i].push(property);
							return;
						}
					}
					
					// For all other bins: [lowerBound, upperBound)
					if (price >= lowerBound && price < upperBound) {
						bins[i]++;
						binProperties[i].push(property);
						return;
					}
				}
			});

			// Calculate median and average size for each bin
			const binSizeStats = binProperties.map(properties => {
				if (properties.length === 0) {
					return { median: 0, average: 0 };
				}
				
				// Filter properties with valid sqm data
				const sizes = properties
					.filter(p => p.sqm && p.sqm > 0)
					.map(p => p.sqm);
				
				if (sizes.length === 0) {
					return { median: 0, average: 0 };
				}
				
				// Calculate median
				sizes.sort((a, b) => a - b);
				const median = sizes.length % 2 === 0
					? (sizes[sizes.length / 2 - 1] + sizes[sizes.length / 2]) / 2
					: sizes[Math.floor(sizes.length / 2)];
				
				// Calculate average
				const average = sizes.reduce((sum, size) => sum + size, 0) / sizes.length;
				
				return { median, average };
			});

			// Debug logging to verify data
			console.log('Price Distribution Chart Data:', {
				totalProperties: validProperties.length,
				bins: bins.slice(),
				binLabels: binLabels.slice(),
				binRanges: binRanges.map(r => ({ start: Math.round(r.start), end: Math.round(r.end) })),
				totalBinned: bins.reduce((a, b) => a + b, 0)
			});

			// Set up dimensions with better margins for readability
			const width = container.offsetWidth;
			const height = container.offsetHeight;
			const margin = { top: 30, right: 25, bottom: 70, left: 60 };
			const chartWidth = width - margin.left - margin.right;
			const chartHeight = height - margin.top - margin.bottom;

			// Create SVG
			const svg = d3.select(container)
				.append("svg")
				.attr("width", width)
				.attr("height", height);

			// Create scales
			const xScale = d3.scaleBand()
				.domain(binLabels)
				.range([0, chartWidth])
				.padding(0.15);

			const yScale = d3.scaleLinear()
				.domain([0, d3.max(bins)])
				.range([chartHeight, 0]);

			// Create chart group
			const chart = svg.append("g")
				.attr("transform", `translate(${margin.left},${margin.top})`);

			// Helper function for formatting prices (used in tooltip)
			const formatPriceTooltip = (price) => {
				if (price >= 1000000) {
					return `‚Ç¨${(price / 1000000).toFixed(2)}M`;
				} else if (price >= 1000) {
					return `‚Ç¨${(price / 1000).toFixed(1)}k`;
				}
				return `‚Ç¨${Math.round(price)}`;
			};

			// Add bars
			const bars = chart.selectAll(".bar")
				.data(bins)
				.enter().append("rect")
				.attr("class", "bar")
				.attr("x", (d, i) => xScale(binLabels[i]))
				.attr("width", xScale.bandwidth())
				.attr("y", d => yScale(d))
				.attr("height", d => chartHeight - yScale(d))
				.attr("fill", "rgba(66, 135, 245, 0.85)")
				.attr("stroke", "#4287f5")
				.attr("stroke-width", 1.5)
				.style("cursor", "pointer")
				.on("mouseover", function(event, d, i) {
					d3.select(this)
						.attr("fill", "rgba(66, 135, 245, 1)")
						.attr("stroke-width", 2.5);
					
					// Get size statistics for this bin
					const sizeStats = binSizeStats && binSizeStats[i] ? binSizeStats[i] : { median: 0, average: 0 };
					const medianSize = sizeStats.median > 0 ? Math.round(sizeStats.median) : 'N/A';
					const avgSize = sizeStats.average > 0 ? Math.round(sizeStats.average) : 'N/A';
					
					// Build tooltip content
					const tooltipContent = `
						<div style="margin-bottom: 4px;"><strong>Price Range:</strong></div>
						<div style="margin-bottom: 8px;">${formatPriceTooltip(binRanges[i].start)} - ${formatPriceTooltip(binRanges[i].end)}</div>
						<div style="margin-bottom: 4px;"><strong>Properties:</strong> ${d}</div>
						<div style="margin-bottom: 4px;"><strong>Median Size:</strong> ${medianSize}${medianSize !== 'N/A' ? ' m¬≤' : ''}</div>
						<div><strong>Average Size:</strong> ${avgSize}${avgSize !== 'N/A' ? ' m¬≤' : ''}</div>
					`;
					
					// Remove any existing tooltips first
					d3.selectAll(".chart-tooltip").remove();
					
					// Show tooltip
					const tooltip = d3.select("body").append("div")
						.attr("class", "chart-tooltip")
						.style("opacity", 0)
						.style("position", "absolute")
						.style("background", "rgba(0, 0, 0, 0.9)")
						.style("color", "white")
						.style("padding", "10px 14px")
						.style("border-radius", "6px")
						.style("font-size", "13px")
						.style("font-weight", "500")
						.style("pointer-events", "none")
						.style("z-index", "10000")
						.style("box-shadow", "0 4px 12px rgba(0,0,0,0.3)")
						.html(tooltipContent)
						.style("left", (event.pageX + 10) + "px")
						.style("top", (event.pageY - 10) + "px");
					
					tooltip.transition()
						.duration(200)
						.style("opacity", 1);
				})
				.on("mouseout", function(event, d) {
					d3.select(this)
						.attr("fill", "rgba(66, 135, 245, 0.85)")
						.attr("stroke-width", 1.5);
					
					d3.selectAll(".chart-tooltip").remove();
				});

			// Add value labels on top of bars for better readability
			chart.selectAll(".value-label")
				.data(bins)
				.enter()
				.append("text")
				.attr("class", "value-label")
				.attr("x", (d, i) => xScale(binLabels[i]) + xScale.bandwidth() / 2)
				.attr("y", (d, i) => yScale(d) - 8)
				.attr("text-anchor", "middle")
				.style("font-size", "12px")
				.style("font-weight", "600")
				.style("fill", "#2c3e50")
				.style("pointer-events", "none")
				.text(d => d > 0 ? d : "");

			// Add axes with better styling - show fewer labels for clarity
			const xAxisGroup = chart.append("g")
				.attr("class", "x-axis")
				.attr("transform", `translate(0,${chartHeight})`)
				.call(d3.axisBottom(xScale)
					.tickSize(5)
					.tickPadding(10)
					.ticks(Math.min(numBins, 6))); // Show max 6 labels

			// Style X-axis text - use horizontal labels for better readability with fewer bins
			// With only 5-8 bins and shorter labels, horizontal should work fine
			const shouldRotate = numBins > 6 || binLabels.some(label => label.length > 8);
			
			xAxisGroup.selectAll("text")
				.style("text-anchor", shouldRotate ? "end" : "middle")
				.attr("dx", shouldRotate ? "-.8em" : "0")
				.attr("dy", shouldRotate ? ".15em" : ".35em")
				.attr("transform", shouldRotate ? "rotate(-45)" : "rotate(0)")
				.style("font-size", "12px")
				.style("font-weight", "500")
				.style("fill", "#444");

			// Style X-axis path and lines
			xAxisGroup.select("path")
				.style("stroke", "#999")
				.style("stroke-width", 1.5);

			xAxisGroup.selectAll("line")
				.style("stroke", "#ccc");

			const yAxisGroup = chart.append("g")
				.attr("class", "y-axis")
				.call(d3.axisLeft(yScale)
					.tickSize(5)
					.tickPadding(8));

			// Style Y-axis text
			yAxisGroup.selectAll("text")
				.style("font-size", "12px")
				.style("font-weight", "500")
				.style("fill", "#444");

			// Style Y-axis path and lines
			yAxisGroup.select("path")
				.style("stroke", "#999")
				.style("stroke-width", 1.5);

			yAxisGroup.selectAll("line")
				.style("stroke", "#ccc");

			// Add axis labels with better styling - positioned further from axes
			chart.append("text")
				.attr("transform", "rotate(-90)")
				.attr("y", 0 - margin.left + 10)
				.attr("x", 0 - (chartHeight / 2))
				.attr("dy", "1em")
				.style("text-anchor", "middle")
				.style("font-size", "13px")
				.style("font-weight", "500")
				.attr("fill", "#444")
				.text("Number of Properties");

			chart.append("text")
				.attr("transform", `translate(${chartWidth / 2}, ${chartHeight + 65})`)
				.style("text-anchor", "middle")
				.style("font-size", "13px")
				.style("font-weight", "500")
				.attr("fill", "#444")
				.text("Price Range");
		}

		// Function to render price vs size scatter plot
		function renderPriceSizeScatterChart(properties) {
			const container = document.getElementById('priceSizeScatterChart');
			if (!container) return;

			// Clear existing content
			container.innerHTML = '';

			// Filter properties with valid price and size data
			const validProperties = properties.filter(p => 
				p.price_amount && p.price_amount > 0 && 
				p.sqm && p.sqm > 0
			);

			if (validProperties.length === 0) {
				container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No valid data available</div>';
				return;
			}

			// Set up dimensions with better margins for readability
			const width = container.offsetWidth;
			const height = container.offsetHeight;
			const margin = { top: 30, right: 100, bottom: 60, left: 70 };
			const chartWidth = width - margin.left - margin.right;
			const chartHeight = height - margin.top - margin.bottom;

			// Create SVG
			const svg = d3.select(container)
				.append("svg")
				.attr("width", width)
				.attr("height", height);

			// Create scales
			const xScale = d3.scaleLinear()
				.domain(d3.extent(validProperties, d => d.sqm))
				.range([0, chartWidth]);

			const yScale = d3.scaleLinear()
				.domain(d3.extent(validProperties, d => d.price_amount))
				.range([chartHeight, 0]);

			// Color scale for condition
			const colorScale = d3.scaleOrdinal()
				.domain(['Good', 'Fair', 'Poor', 'Unknown'])
				.range(['#2ecc71', '#f39c12', '#e74c3c', '#95a5a6']);

			// Create chart group
			const chart = svg.append("g")
				.attr("transform", `translate(${margin.left},${margin.top})`);

			// Helper function for formatting prices
			const formatPrice = (price) => {
				if (price >= 1000000) {
					return `‚Ç¨${(price / 1000000).toFixed(1)}M`;
				} else if (price >= 1000) {
					return `‚Ç¨${Math.round(price / 1000)}k`;
				}
				return `‚Ç¨${Math.round(price)}`;
			};

			// Add gridlines for better readability
			const xGridlines = d3.axisBottom(xScale)
				.tickSize(-chartHeight)
				.tickFormat("")
				.ticks(5);
			
			const yGridlines = d3.axisLeft(yScale)
				.tickSize(-chartWidth)
				.tickFormat("")
				.ticks(5);

			chart.append("g")
				.attr("class", "grid")
				.attr("transform", `translate(0,${chartHeight})`)
				.call(xGridlines)
				.selectAll("line")
				.style("stroke", "#e0e0e0")
				.style("stroke-width", 1)
				.style("stroke-dasharray", "3,3");

			chart.append("g")
				.attr("class", "grid")
				.call(yGridlines)
				.selectAll("line")
				.style("stroke", "#e0e0e0")
				.style("stroke-width", 1)
				.style("stroke-dasharray", "3,3");

			// Add dots with better visibility
			const dots = chart.selectAll(".dot")
				.data(validProperties)
				.enter().append("circle")
				.attr("class", "dot")
				.attr("cx", d => xScale(d.sqm))
				.attr("cy", d => yScale(d.price_amount))
				.attr("r", 5)
				.attr("fill", d => {
					if (d.good_condition === true) return colorScale('Good');
					if (d.needs_renovation === true) return colorScale('Poor');
					return colorScale('Unknown');
				})
				.attr("stroke", "#fff")
				.attr("stroke-width", 1.5)
				.attr("opacity", 0.75)
				.style("cursor", "pointer")
				.on("mouseover", function(event, d) {
					d3.select(this)
						.attr("opacity", 1)
						.attr("r", 7)
						.attr("stroke-width", 2);
					
					// Show tooltip
					const tooltip = d3.select("body").append("div")
						.attr("class", "chart-tooltip")
						.style("opacity", 0)
						.style("position", "absolute")
						.style("background", "rgba(0, 0, 0, 0.9)")
						.style("color", "white")
						.style("padding", "10px 14px")
						.style("border-radius", "6px")
						.style("font-size", "13px")
						.style("font-weight", "500")
						.style("pointer-events", "none")
						.style("z-index", "1000")
						.style("box-shadow", "0 4px 12px rgba(0,0,0,0.3)");
					
					tooltip.transition()
						.duration(200)
						.style("opacity", 1);
					
					const pricePerSqm = d.price_amount / d.sqm;
					tooltip.html(`
						<div style="margin-bottom: 6px;"><strong>Price:</strong> ${formatPrice(d.price_amount)}</div>
						<div style="margin-bottom: 6px;"><strong>Size:</strong> ${Math.round(d.sqm)} m¬≤</div>
						<div><strong>Price/m¬≤:</strong> ${formatPrice(pricePerSqm)}</div>
					`)
						.style("left", (event.pageX + 10) + "px")
						.style("top", (event.pageY - 10) + "px");
				})
				.on("mouseout", function(event, d) {
					d3.select(this)
						.attr("opacity", 0.75)
						.attr("r", 5)
						.attr("stroke-width", 1.5);
					
					d3.selectAll(".chart-tooltip").remove();
				});

			// Add axes with better formatting and styling
			const xAxisGroup = chart.append("g")
				.attr("class", "x-axis")
				.attr("transform", `translate(0,${chartHeight})`)
				.call(d3.axisBottom(xScale)
					.tickSize(5)
					.tickPadding(10)
					.ticks(6)
					.tickFormat(d => Math.round(d) + " m¬≤"));

			xAxisGroup.selectAll("text")
				.style("font-size", "12px")
				.style("font-weight", "500")
				.style("fill", "#444");

			xAxisGroup.select("path")
				.style("stroke", "#999")
				.style("stroke-width", 1.5);

			xAxisGroup.selectAll("line")
				.style("stroke", "#ccc");

			const yAxisGroup = chart.append("g")
				.attr("class", "y-axis")
				.call(d3.axisLeft(yScale)
					.tickSize(5)
					.tickPadding(10)
					.ticks(6)
					.tickFormat(d => {
						if (d >= 1000000) {
							return `‚Ç¨${(d / 1000000).toFixed(1)}M`;
						} else if (d >= 1000) {
							return `‚Ç¨${Math.round(d / 1000)}k`;
						}
						return `‚Ç¨${Math.round(d)}`;
					}));

			yAxisGroup.selectAll("text")
				.style("font-size", "12px")
				.style("font-weight", "500")
				.style("fill", "#444");

			yAxisGroup.select("path")
				.style("stroke", "#999")
				.style("stroke-width", 1.5);

			yAxisGroup.selectAll("line")
				.style("stroke", "#ccc");

			// Add axis labels with better styling
			chart.append("text")
				.attr("transform", "rotate(-90)")
				.attr("y", 0 - margin.left - 20)
				.attr("x", 0 - (chartHeight / 2))
				.attr("dy", "1em")
				.style("text-anchor", "middle")
				.style("font-size", "13px")
				.style("font-weight", "500")
				.attr("fill", "#444")
				.text("Price (‚Ç¨)");

			chart.append("text")
				.attr("transform", `translate(${chartWidth / 2}, ${chartHeight + 50})`)
				.style("text-anchor", "middle")
				.style("font-size", "13px")
				.style("font-weight", "500")
				.attr("fill", "#444")
				.text("Size (m¬≤)");

			// Add legend with better styling - positioned at the top of the chart area
			const legend = svg.append("g")
				.attr("transform", `translate(${margin.left + chartWidth / 2 - 80}, ${margin.top - 20})`);

			const legendData = [
				{ label: "Good Condition", color: colorScale('Good') },
				{ label: "Needs Work", color: colorScale('Poor') },
				{ label: "Unknown", color: colorScale('Unknown') }
			];

			legend.selectAll(".legend-item")
				.data(legendData)
				.enter().append("g")
				.attr("class", "legend-item")
				.attr("transform", (d, i) => `translate(${i * 140}, 0)`)
				.each(function(d) {
					const g = d3.select(this);
					g.append("circle")
						.attr("r", 6)
						.attr("fill", d.color)
						.attr("stroke", "#fff")
						.attr("stroke-width", 1.5);
					g.append("text")
						.attr("x", 16)
						.attr("y", 5)
						.style("font-size", "12px")
						.style("font-weight", "500")
						.attr("fill", "#444")
						.text(d.label);
				});
		}

		// Function to generate market summary
		function generateMarketSummary(metrics, properties) {
			const summaryElement = document.getElementById('marketSummary');
			if (!summaryElement) return;

			const validProperties = metrics.validProperties || properties.filter(p => 
				p.price_amount && p.price_amount > 0 && p.sqm && p.sqm > 0
			);

			// Calculate price distribution insights
			const priceRanges = {
				budget: validProperties.filter(p => p.price_amount < metrics.avgPrice * 0.7).length,
				midRange: validProperties.filter(p => p.price_amount >= metrics.avgPrice * 0.7 && p.price_amount <= metrics.avgPrice * 1.3).length,
				premium: validProperties.filter(p => p.price_amount > metrics.avgPrice * 1.3).length
			};

			const totalValid = priceRanges.budget + priceRanges.midRange + priceRanges.premium;
			const budgetPct = Math.round((priceRanges.budget / totalValid) * 100);
			const midRangePct = Math.round((priceRanges.midRange / totalValid) * 100);
			const premiumPct = Math.round((priceRanges.premium / totalValid) * 100);

			// Determine market type
			let marketType = "mid-range";
			if (budgetPct > 50) marketType = "budget-focused";
			else if (premiumPct > 50) marketType = "premium-focused";

			// Generate summary text
			const summary = `
				This area shows a <strong>${marketType}</strong> property market with <strong>${metrics.listingsCount} listings</strong>. 
				The average price is <strong>‚Ç¨${Math.round(metrics.avgPrice).toLocaleString()}</strong> with a median of 
				<strong>‚Ç¨${Math.round(metrics.medianPrice).toLocaleString()}</strong>. Most properties are priced between 
				<strong>‚Ç¨${Math.round(metrics.priceRange.min).toLocaleString()}</strong> and 
				<strong>‚Ç¨${Math.round(metrics.priceRange.max).toLocaleString()}</strong>.
				<br><br>
				Price distribution: <strong>${budgetPct}% budget</strong>, <strong>${midRangePct}% mid-range</strong>, <strong>${premiumPct}% premium</strong>.
				The average price per square meter is <strong>‚Ç¨${Math.round(metrics.avgPricePerSqm).toLocaleString()}</strong>.
			`;

			summaryElement.innerHTML = summary;
		}

		// Global variables for map view
		let propertyMap = null;
		let mapMarkers = [];
		let heatmapLayer = null;
		let isHeatmapMode = false;
		let isMarkersMode = true;

		// Function to process map view data
		function processMapView(data) {
			try {
				const mapContainer = document.getElementById('mapViewContainer');
				
				// Check if property data exists
				if (!data || !data.data || !data.data.properties || !data.data.properties.rows) {
					console.log('[Map View] No property data available');
					return;
				}

				const properties = data.data.properties.rows;
				console.log('[Map View] Processing map view for', properties.length, 'properties');

				if (properties.length === 0) {
					console.log('[Map View] No properties to display');
					return;
				}

				// Update property count
				const countElement = document.getElementById('mapPropertyCount');
				if (countElement) {
					countElement.textContent = properties.length;
				}

				// Initialize map with a small delay to ensure DOM is ready
				setTimeout(() => {
					try {
						initializePropertyMap(properties);
					} catch (error) {
						console.error('Error in map initialization timeout:', error);
						// Show a simple fallback
						const mapElement = document.getElementById('propertyMap');
						if (mapElement) {
							mapElement.innerHTML = `
								<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #666; text-align: center; padding: 20px;">
									<div style="font-size: 24px; margin-bottom: 10px;">üó∫Ô∏è</div>
									<div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Map View</div>
									<div style="font-size: 14px;">${properties.length} properties found</div>
									<div style="font-size: 12px; color: #999; margin-top: 8px;">Interactive map temporarily unavailable</div>
								</div>
							`;
						}
					}
				}, 100);
			} catch (error) {
				console.error('Error processing map view:', error);
			}
		}

		// Function to initialize the property map
		function initializePropertyMap(properties) {
			try {
				// Check if map container exists
				const mapElement = document.getElementById('propertyMap');
				if (!mapElement) {
					console.error('Map container not found');
					return;
				}

				// Check if Leaflet is available
				if (typeof L === 'undefined') {
					console.error('Leaflet library not loaded');
					mapElement.innerHTML = 
						'<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #e74c3c;">Map library not loaded</div>';
					return;
				}

				// Clean up existing map
				if (propertyMap) {
					propertyMap.remove();
				}

				// Filter properties with valid coordinates
				const validProperties = properties.filter(p => 
					p.latitude && p.longitude && 
					!isNaN(parseFloat(p.latitude)) && 
					!isNaN(parseFloat(p.longitude))
				);

				if (validProperties.length === 0) {
					mapElement.innerHTML = 
						'<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No properties with valid coordinates found</div>';
					return;
				}

				// Calculate map bounds
				const lats = validProperties.map(p => parseFloat(p.latitude));
				const lons = validProperties.map(p => parseFloat(p.longitude));
				const bounds = [[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]];

				// Initialize map
				propertyMap = L.map('propertyMap').fitBounds(bounds, { padding: [20, 20] });
				
				// Store map instance globally for resize handling
				window.propertyMapInstance = propertyMap;

				// Add tile layer
				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution: '¬© OpenStreetMap contributors'
				}).addTo(propertyMap);

				// Create price ranges and color scale
				const priceRanges = createPriceRanges(validProperties);
				const colorScale = createPriceColorScale(priceRanges);

				// Add markers
				addPropertyMarkers(validProperties, colorScale);

				// Add heatmap layer
				addHeatmapLayer(validProperties);

				// Update legend
				updatePriceLegend(priceRanges, colorScale);

				// Set up control event listeners
				setupMapControls();
			} catch (error) {
				console.error('Error initializing property map:', error);
				const mapElement = document.getElementById('propertyMap');
				if (mapElement) {
					mapElement.innerHTML = 
						'<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #e74c3c;">Error loading map</div>';
				}
			}
		}

		// Function to create price ranges
		function createPriceRanges(properties) {
			const prices = properties.map(p => p.price_amount || 0).filter(p => p > 0);
			if (prices.length === 0) return [];

			prices.sort((a, b) => a - b);
			const min = prices[0];
			const max = prices[prices.length - 1];
			const range = max - min;

			// Create 5 price ranges
			const ranges = [];
			for (let i = 0; i < 5; i++) {
				const start = min + (range * i / 5);
				const end = min + (range * (i + 1) / 5);
				ranges.push({
					min: Math.round(start),
					max: Math.round(end),
					label: `‚Ç¨${Math.round(start / 1000)}k - ‚Ç¨${Math.round(end / 1000)}k`
				});
			}

			return ranges;
		}

		// Function to create color scale
		function createPriceColorScale(ranges) {
			const colors = ['#2ecc71', '#f39c12', '#e67e22', '#e74c3c', '#8e44ad'];
			const colorMap = {};
			ranges.forEach((range, index) => {
				colorMap[`${range.min}-${range.max}`] = colors[index] || colors[colors.length - 1];
			});
			return (key) => colorMap[key] || colors[colors.length - 1];
		}

		// Function to get price range for a property
		function getPriceRange(price, ranges) {
			for (let range of ranges) {
				if (price >= range.min && price <= range.max) {
					return `${range.min}-${range.max}`;
				}
			}
			return ranges[ranges.length - 1].min + '-' + ranges[ranges.length - 1].max;
		}

		// Function to add property markers
		function addPropertyMarkers(properties, colorScale) {
			try {
				if (!propertyMap) return;

				// Clear existing markers
				mapMarkers.forEach(marker => propertyMap.removeLayer(marker));
				mapMarkers = [];

				// Create price ranges for color assignment
				const priceRanges = createPriceRanges(properties);

				properties.forEach(property => {
					const lat = parseFloat(property.latitude);
					const lon = parseFloat(property.longitude);
					const price = property.price_amount || 0;

					// Get color based on price range
					const priceRange = getPriceRange(price, priceRanges);
					const color = colorScale(priceRange);

					// Create marker
					const marker = L.circleMarker([lat, lon], {
						radius: 8,
						fillColor: color,
						color: '#fff',
						weight: 2,
						opacity: 1,
						fillOpacity: 0.8
					}).addTo(propertyMap);

					// Add popup with property details
					const popupContent = `
						<div style="min-width: 200px;">
							<h6 style="margin: 0 0 8px 0; color: #333;">${property.address_property || 'Address not available'}</h6>
							<div style="margin-bottom: 4px;">
								<strong>Price:</strong> ‚Ç¨${price.toLocaleString()}
							</div>
							<div style="margin-bottom: 4px;">
								<strong>Size:</strong> ${property.sqm || 'N/A'} m¬≤
							</div>
							<div style="margin-bottom: 4px;">
								<strong>Rooms:</strong> ${property.rooms || 'N/A'}
							</div>
							${property.price_per_sqm ? `
							<div style="margin-bottom: 4px;">
								<strong>Price/m¬≤:</strong> ‚Ç¨${Math.round(property.price_per_sqm).toLocaleString()}
							</div>
							` : ''}
							${property.condition_property ? `
							<div style="margin-bottom: 4px;">
								<strong>Condition:</strong> ${property.condition_property}
							</div>
							` : ''}
							<div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #eee;">
								<a href="${property.url || '#'}" 
								   target="_blank" 
								   style="display: inline-block; 
								          background: #4287f5; 
								          color: white; 
								          text-decoration: none; 
								          padding: 6px 12px; 
								          border-radius: 4px; 
								          font-size: 12px; 
								          font-weight: 500;
								          transition: background-color 0.2s;">
									üîó View Listing
								</a>
							</div>
						</div>
					`;

					marker.bindPopup(popupContent);
					mapMarkers.push(marker);
				});
			} catch (error) {
				console.error('Error adding property markers:', error);
			}
		}

		// Function to add heatmap layer
		function addHeatmapLayer(properties) {
			try {
				if (!propertyMap) return;

				// Clear existing heatmap
				if (heatmapLayer) {
					propertyMap.removeLayer(heatmapLayer);
				}

				// Prepare heatmap data
				const heatmapData = properties
					.filter(p => p.latitude && p.longitude && p.price_amount)
					.map(p => ({
						lat: parseFloat(p.latitude),
						lng: parseFloat(p.longitude),
						count: 1,
						weight: p.price_amount / 1000000 // Normalize weight by price
					}));

				if (heatmapData.length > 0) {
					// Create heatmap layer (using a simple circle-based approach)
					heatmapLayer = L.layerGroup();
					
					heatmapData.forEach(point => {
						const radius = Math.max(20, Math.min(100, point.weight * 50));
						const circle = L.circle([point.lat, point.lng], {
							radius: radius,
							fillColor: '#ff4444',
							color: '#ff4444',
							weight: 1,
							opacity: 0.3,
							fillOpacity: 0.2
						});
						heatmapLayer.addLayer(circle);
					});

					// Add to map but keep hidden initially
					heatmapLayer.addTo(propertyMap);
					heatmapLayer.setOpacity(0);
				}
			} catch (error) {
				console.error('Error adding heatmap layer:', error);
			}
		}

		// Function to update price legend
		function updatePriceLegend(ranges, colorScale) {
			try {
				const legendContainer = document.getElementById('legendItems');
				if (!legendContainer) return;

				legendContainer.innerHTML = '';

				ranges.forEach(range => {
					const rangeKey = `${range.min}-${range.max}`;
					const color = colorScale(rangeKey);
					
					const legendItem = document.createElement('div');
					legendItem.style.display = 'flex';
					legendItem.style.alignItems = 'center';
					legendItem.style.gap = '6px';
					
					legendItem.innerHTML = `
						<div style="width: 12px; height: 12px; background-color: ${color}; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 0 1px #ddd;"></div>
						<span>${range.label}</span>
					`;
					
					legendContainer.appendChild(legendItem);
				});
			} catch (error) {
				console.error('Error updating price legend:', error);
			}
		}

		// Function to setup map controls
		function setupMapControls() {
			try {
				const toggleHeatmap = document.getElementById('toggleHeatmap');
				const toggleMarkers = document.getElementById('toggleMarkers');

				if (toggleHeatmap) {
					toggleHeatmap.addEventListener('click', function() {
						try {
							isHeatmapMode = !isHeatmapMode;
							
							if (isHeatmapMode) {
								// Show heatmap, hide markers
								if (heatmapLayer) {
									heatmapLayer.setOpacity(0.6);
								}
								mapMarkers.forEach(marker => marker.setOpacity(0.3));
								this.className = 'btn btn-sm btn-primary';
								const icon = document.getElementById('heatmapIcon');
								if (icon) icon.textContent = 'üî•';
							} else {
								// Hide heatmap, show markers
								if (heatmapLayer) {
									heatmapLayer.setOpacity(0);
								}
								mapMarkers.forEach(marker => marker.setOpacity(1));
								this.className = 'btn btn-sm btn-outline-primary';
								const icon = document.getElementById('heatmapIcon');
								if (icon) icon.textContent = 'üî•';
							}
						} catch (error) {
							console.error('Error toggling heatmap:', error);
						}
					});
				}

				if (toggleMarkers) {
					toggleMarkers.addEventListener('click', function() {
						try {
							isMarkersMode = !isMarkersMode;
							
							if (isMarkersMode) {
								// Show markers
								mapMarkers.forEach(marker => marker.setOpacity(1));
								this.className = 'btn btn-sm btn-primary';
								const icon = document.getElementById('markersIcon');
								if (icon) icon.textContent = 'üìç';
							} else {
								// Hide markers
								mapMarkers.forEach(marker => marker.setOpacity(0));
								this.className = 'btn btn-sm btn-outline-primary';
								const icon = document.getElementById('markersIcon');
								if (icon) icon.textContent = 'üìç';
							}
						} catch (error) {
							console.error('Error toggling markers:', error);
						}
					});
				}
			} catch (error) {
				console.error('Error setting up map controls:', error);
			}
		}

		// Function to initialize listings controls
		function initializeListingsControls() {
			const sortSelect = document.getElementById('sortSelect');
			const toggleViewBtn = document.getElementById('toggleViewBtn');

			// Sort dropdown functionality
			if (sortSelect) {
				sortSelect.addEventListener('change', function() {
					const selectedValue = this.value;
					console.log('Sort option selected:', selectedValue);
					
					// Store the current sort option
					currentSortOption = selectedValue || null;
					
					if (!selectedValue || !allPropertyData || allPropertyData.length === 0) {
						return;
					}
					
					// Sort the property data based on selected option
					let sortedData = [...allPropertyData]; // Create a copy to avoid mutating original
					
					switch(selectedValue) {
						case 'price-low-high':
							sortedData.sort((a, b) => {
								const priceA = a.price_amount || 0;
								const priceB = b.price_amount || 0;
								return priceA - priceB;
							});
							break;
							
						case 'price-high-low':
							sortedData.sort((a, b) => {
								const priceA = a.price_amount || 0;
								const priceB = b.price_amount || 0;
								return priceB - priceA;
							});
							break;
							
						case 'size-low-high':
							sortedData.sort((a, b) => {
								const sizeA = a.sqm || 0;
								const sizeB = b.sqm || 0;
								return sizeA - sizeB; // Smallest first
							});
							break;
							
						case 'size-high-low':
							sortedData.sort((a, b) => {
								const sizeA = a.sqm || 0;
								const sizeB = b.sqm || 0;
								return sizeB - sizeA; // Largest first
							});
							break;
							
						default:
							console.log('Unknown sort option:', selectedValue);
							currentSortOption = null;
							return;
					}
					
					// Update the global property data array with sorted data
					allPropertyData = sortedData;
					currentPage = 1; // Reset to first page after sorting
					
					// Re-render the current page with sorted data
					renderPropertyPage(1);
					
					console.log('Properties sorted by:', selectedValue);
				});
			}

			// Filter functionality
			initializeFilters();

			// View toggle functionality
			if (toggleViewBtn) {
				console.log('[Toggle View] Button found, setting up event listener');
				// Remove any existing event listeners by cloning the button
				const newToggleBtn = toggleViewBtn.cloneNode(true);
				toggleViewBtn.parentNode.replaceChild(newToggleBtn, toggleViewBtn);
				
				// Add event listener to the new button
				newToggleBtn.addEventListener('click', function(e) {
					e.preventDefault();
					e.stopPropagation();
					console.log('[Toggle View] Button clicked, current isMapView:', isMapView);
					toggleView();
					return false;
				});
				console.log('[Toggle View] ‚úÖ Event listener added to button');
			} else {
				console.error('[Toggle View] ‚ùå toggleViewBtn not found');
			}
			
			// Also set up event delegation as a backup (only once)
			if (!window.toggleViewDelegationAdded) {
				document.addEventListener('click', function(e) {
					if (e.target && (e.target.id === 'toggleViewBtn' || e.target.closest('#toggleViewBtn'))) {
						e.preventDefault();
						e.stopPropagation();
						console.log('[Toggle View] ‚úÖ Button clicked via delegation!');
						toggleView();
						return false;
					}
				});
				window.toggleViewDelegationAdded = true;
				console.log('[Toggle View] ‚úÖ Event delegation added as backup');
			}
		}
		
		// Function to apply filters to property listings
		function applyFilters() {
			if (!originalPropertyData || originalPropertyData.length === 0) {
				return;
			}
			
			// Start with all original properties
			let filtered = [...originalPropertyData];
			
			// Filter by price
			if (filterState.minPrice !== null) {
				filtered = filtered.filter(p => p.price_amount && p.price_amount >= filterState.minPrice);
			}
			if (filterState.maxPrice !== null) {
				filtered = filtered.filter(p => p.price_amount && p.price_amount <= filterState.maxPrice);
			}
			
			// Filter by size
			if (filterState.minSize !== null) {
				filtered = filtered.filter(p => p.sqm && p.sqm >= filterState.minSize);
			}
			if (filterState.maxSize !== null) {
				filtered = filtered.filter(p => p.sqm && p.sqm <= filterState.maxSize);
			}
			
			// Filter by rooms
			if (filterState.minRooms !== null) {
				filtered = filtered.filter(p => {
					const rooms = p.rooms || 0;
					return rooms >= filterState.minRooms && (filterState.maxRooms === null || rooms <= filterState.maxRooms);
				});
			} else if (filterState.maxRooms !== null) {
				// Only max rooms specified
				filtered = filtered.filter(p => {
					const rooms = p.rooms || 0;
					return rooms <= filterState.maxRooms;
				});
			}
			
			// Filter by features
			if (filterState.features && filterState.features.length > 0) {
				filtered = filtered.filter(p => {
					// Check each selected feature
					for (const feature of filterState.features) {
						if (feature === 'balcony') {
							// Check has_terrace_balcony_patio field - must be TRUE
							if (!p.has_terrace_balcony_patio || p.has_terrace_balcony_patio !== true) {
								return false;
							}
						}
						// Add other feature checks here as needed when property field names are known
						// For example:
						// if (feature === 'parking' && !p.has_parking) return false;
						// if (feature === 'elevator' && !p.has_elevator) return false;
						// etc.
					}
					return true;
				});
			}
			
			// Update allPropertyData with filtered results
			allPropertyData = filtered;
			
			// Re-apply sorting if there was a sort option selected
			if (currentSortOption) {
				let sortedData = [...allPropertyData];
				
				switch(currentSortOption) {
					case 'price-low-high':
						sortedData.sort((a, b) => {
							const priceA = a.price_amount || 0;
							const priceB = b.price_amount || 0;
							return priceA - priceB;
						});
						break;
						
					case 'price-high-low':
						sortedData.sort((a, b) => {
							const priceA = a.price_amount || 0;
							const priceB = b.price_amount || 0;
							return priceB - priceA;
						});
						break;
						
					case 'size-low-high':
						sortedData.sort((a, b) => {
							const sizeA = a.sqm || 0;
							const sizeB = b.sqm || 0;
							return sizeA - sizeB;
						});
						break;
						
					case 'size-high-low':
						sortedData.sort((a, b) => {
							const sizeA = a.sqm || 0;
							const sizeB = b.sqm || 0;
							return sizeB - sizeA;
						});
						break;
				}
				
				allPropertyData = sortedData;
			}
			
			currentPage = 1; // Reset to first page after filtering
			
			console.log(`Filtered properties: ${filtered.length} out of ${originalPropertyData.length}`, filterState);
			
			// Update results count display
			updateResultsCountDisplay();
			
			// Re-render the page
			renderPropertyPage(1);
		}
		
		// Function to update results count display
		function updateResultsCountDisplay() {
			const resultsCountDisplay = document.getElementById('resultsCountDisplay');
			const resultsCount = document.getElementById('resultsCount');
			
			if (!resultsCountDisplay || !resultsCount) {
				return;
			}
			
			// Get the count from filtered data (allPropertyData)
			const count = allPropertyData ? allPropertyData.length : 0;
			
			// Update display
			const countText = count === 1 ? '1 Result Found' : `${count.toLocaleString()} Results Found`;
			resultsCount.textContent = countText;
		}
		
		// Function to initialize filter event listeners
		function initializeFilters() {
			// Price filter handlers
			const priceApply = document.getElementById('priceApply');
			const priceClear = document.getElementById('priceClear');
			const minPriceInput = document.getElementById('minPrice');
			const maxPriceInput = document.getElementById('maxPrice');
			
			if (priceApply) {
				priceApply.addEventListener('click', function() {
					const minPrice = minPriceInput ? parseInt(minPriceInput.value) : null;
					const maxPrice = maxPriceInput ? parseInt(maxPriceInput.value) : null;
					
					// Validate
					if (minPrice !== null && maxPrice !== null && minPrice > maxPrice) {
						alert('Min price cannot be greater than max price');
						return;
					}
					
					filterState.minPrice = minPrice || null;
					filterState.maxPrice = maxPrice || null;
					
					// Close popover
					const pricePopover = document.getElementById('pricePopover');
					if (pricePopover) {
						pricePopover.style.display = 'none';
					}
					
					// Apply filters
					applyFilters();
				});
			}
			
			if (priceClear) {
				priceClear.addEventListener('click', function() {
					filterState.minPrice = null;
					filterState.maxPrice = null;
					if (minPriceInput) minPriceInput.value = '';
					if (maxPriceInput) maxPriceInput.value = '';
					
					// Close popover
					const pricePopover = document.getElementById('pricePopover');
					if (pricePopover) {
						pricePopover.style.display = 'none';
					}
					
					// Apply filters
					applyFilters();
				});
			}
			
			// Size filter handlers
			const sizeApply = document.getElementById('sizeApply');
			const sizeClear = document.getElementById('sizeClear');
			const minSizeInput = document.getElementById('minSize');
			const maxSizeInput = document.getElementById('maxSize');
			
			if (sizeApply) {
				sizeApply.addEventListener('click', function() {
					const minSize = minSizeInput ? parseInt(minSizeInput.value) : null;
					const maxSize = maxSizeInput ? parseInt(maxSizeInput.value) : null;
					
					// Validate
					if (minSize !== null && maxSize !== null && minSize > maxSize) {
						alert('Min size cannot be greater than max size');
						return;
					}
					
					filterState.minSize = minSize || null;
					filterState.maxSize = maxSize || null;
					
					// Close popover
					const sizePopover = document.getElementById('sizePopover');
					if (sizePopover) {
						sizePopover.style.display = 'none';
					}
					
					// Apply filters
					applyFilters();
				});
			}
			
			if (sizeClear) {
				sizeClear.addEventListener('click', function() {
					filterState.minSize = null;
					filterState.maxSize = null;
					if (minSizeInput) minSizeInput.value = '';
					if (maxSizeInput) maxSizeInput.value = '';
					
					// Close popover
					const sizePopover = document.getElementById('sizePopover');
					if (sizePopover) {
						sizePopover.style.display = 'none';
					}
					
					// Apply filters
					applyFilters();
				});
			}
			
			// Rooms filter handlers
			const roomsTrigger = document.getElementById('roomsTrigger');
			const roomsPopover = document.getElementById('roomsPopover');
			const roomsApply = document.getElementById('roomsApply');
			const roomsClear = document.getElementById('roomsClear');
			const roomsCancel = document.getElementById('roomsCancel');
			const minRoomsInput = document.getElementById('minRooms');
			const maxRoomsInput = document.getElementById('maxRooms');
			
			// Open/close rooms popover
			if (roomsTrigger && roomsPopover) {
				roomsTrigger.addEventListener('click', function() {
					const isOpen = roomsPopover.style.display === 'block';
					roomsPopover.style.display = isOpen ? 'none' : 'block';
					roomsTrigger.setAttribute('aria-expanded', isOpen ? 'false' : 'true');
					if (!isOpen && minRoomsInput) {
						minRoomsInput.focus();
					}
				});
			}
			
			// Close popover on outside click
			document.addEventListener('click', function(e) {
				if (roomsPopover && roomsTrigger && roomsPopover.style.display === 'block') {
					if (!roomsPopover.contains(e.target) && !roomsTrigger.contains(e.target)) {
						roomsPopover.style.display = 'none';
						if (roomsTrigger) {
							roomsTrigger.setAttribute('aria-expanded', 'false');
						}
					}
				}
			});
			
			// Cancel button
			if (roomsCancel && roomsPopover) {
				roomsCancel.addEventListener('click', function() {
					// Reset inputs to current state
					if (minRoomsInput) minRoomsInput.value = filterState.minRooms || '';
					if (maxRoomsInput) maxRoomsInput.value = filterState.maxRooms || '';
					roomsPopover.style.display = 'none';
					if (roomsTrigger) {
						roomsTrigger.setAttribute('aria-expanded', 'false');
					}
				});
			}
			
			if (roomsApply) {
				roomsApply.addEventListener('click', function() {
					const minRooms = minRoomsInput ? parseInt(minRoomsInput.value) : null;
					const maxRooms = maxRoomsInput ? parseInt(maxRoomsInput.value) : null;
					
					// Validate
					if (minRooms !== null && maxRooms !== null && minRooms > maxRooms) {
						alert('Min rooms cannot be greater than max rooms');
						return;
					}
					
					filterState.minRooms = minRooms || null;
					filterState.maxRooms = maxRooms || null;
					
					// Close popover
					if (roomsPopover) {
						roomsPopover.style.display = 'none';
					}
					if (roomsTrigger) {
						roomsTrigger.setAttribute('aria-expanded', 'false');
					}
					
					// Apply filters
					applyFilters();
				});
			}
			
			if (roomsClear) {
				roomsClear.addEventListener('click', function() {
					filterState.minRooms = null;
					filterState.maxRooms = null;
					if (minRoomsInput) minRoomsInput.value = '';
					if (maxRoomsInput) maxRoomsInput.value = '';
					
					// Close popover
					if (roomsPopover) {
						roomsPopover.style.display = 'none';
					}
					if (roomsTrigger) {
						roomsTrigger.setAttribute('aria-expanded', 'false');
					}
					
					// Apply filters
					applyFilters();
				});
			}
		}

		// Function to toggle between map and list view
		function toggleView() {
			const listingsContainer = document.getElementById('listingsContainer') || document.querySelector('.listings');
			const mapViewContainer = document.getElementById('mapViewContainer');
			const toggleViewBtn = document.getElementById('toggleViewBtn');

			console.log('[Toggle View] toggleView() called');
			console.log('[Toggle View] Elements found:', {
				listingsContainer: !!listingsContainer,
				mapViewContainer: !!mapViewContainer,
				toggleViewBtn: !!toggleViewBtn
			});

			if (!listingsContainer || !mapViewContainer || !toggleViewBtn) {
				console.error('[Toggle View] ‚ùå Required elements not found');
				console.error('[Toggle View] listingsContainer:', listingsContainer);
				console.error('[Toggle View] mapViewContainer:', mapViewContainer);
				console.error('[Toggle View] toggleViewBtn:', toggleViewBtn);
				return;
			}

			isMapView = !isMapView;
			console.log('[Toggle View] isMapView toggled to:', isMapView);

			if (isMapView) {
				// Switch to Map View
				console.log('[Toggle View] Switching to Map View');
				
				// Store original listings content if not already stored
				if (!originalListingsContent) {
					originalListingsContent = listingsContainer.innerHTML;
				}
				
				// Hide only compare controls (keep filter card and results count visible)
				const compareControls = document.getElementById('compareControls');
				if (compareControls) compareControls.style.display = 'none';
				
				// Calculate the height of elements above the map (filter card + results count)
				const filterCard = document.querySelector('#listingsPanel > .card:first-child');
				const resultsCountDisplay = document.getElementById('resultsCountDisplay');
				let topOffset = 0;
				
				if (filterCard) {
					const filterRect = filterCard.getBoundingClientRect();
					const panelRect = listingsContainer.closest('#listingsPanel').getBoundingClientRect();
					topOffset = filterRect.bottom - panelRect.top + 8; // Add gap
				}
				
				if (resultsCountDisplay) {
					const resultsRect = resultsCountDisplay.getBoundingClientRect();
					const panelRect = listingsContainer.closest('#listingsPanel').getBoundingClientRect();
					topOffset = resultsRect.bottom - panelRect.top + 8; // Add gap
				}
				
				// Position map container below filter card and results count
				mapViewContainer.style.top = topOffset + 'px';
				
				// Hide listings, show map
				listingsContainer.style.display = 'none';
				mapViewContainer.style.display = 'flex'; // Use flex to fill space
				toggleViewBtn.textContent = 'Switch to List View';
				
				// Initialize map if it hasn't been initialized yet and we have property data
				if (window.lastApiResponse && window.lastApiResponse.data && window.lastApiResponse.data.properties) {
					// Check if map is already initialized
					const mapElement = document.getElementById('propertyMap');
					if (mapElement && (!window.propertyMapInstance || !window.propertyMapInstance._loaded)) {
						console.log('[Toggle View] Initializing map...');
						processMapView(window.lastApiResponse);
					} else if (mapElement && window.propertyMapInstance && window.propertyMapInstance._loaded) {
						// If map already exists, invalidate size to ensure it resizes properly
						setTimeout(() => {
							if (window.propertyMapInstance && typeof window.propertyMapInstance.invalidateSize === 'function') {
								window.propertyMapInstance.invalidateSize();
								console.log('[Toggle View] Map size invalidated');
							}
						}, 100);
					}
				}
			} else {
				// Switch to List View
				console.log('[Toggle View] Switching to List View');
				
				// Show compare controls if properties are selected (filter card and results count are always visible)
				const compareControls = document.getElementById('compareControls');
				if (compareControls && selectedProperties && selectedProperties.length > 0) {
					compareControls.style.display = 'block';
				}
				
				// Hide map, show listings
				mapViewContainer.style.display = 'none';
				listingsContainer.style.display = 'block';
				toggleViewBtn.textContent = 'Switch to Map View';
				
				// Restore original listings content if available
				if (originalListingsContent) {
					listingsContainer.innerHTML = originalListingsContent;
					// Re-initialize event listeners for checkboxes and other interactive elements
					initializeListingsControls();
				} else {
					// If no stored content, re-render from current data
					if (allPropertyData && allPropertyData.length > 0) {
						renderPropertyPage(currentPage || 1);
					}
				}
			}
		}

		// Global variable to store demographics data for chart rendering
		let demographicsData = null;


		// Function to render demographics data
		function renderDemographics(rows) {
			console.log('renderDemographics called with rows:', rows);
			
			// Check if data is valid
			if (!rows || !Array.isArray(rows) || rows.length === 0) {
				console.log('Invalid demographics data');
				demographicsData = null;
				return;
			}
			
			// Define the mapping between indicator_code ‚Üí label + category
			const indicatorMap = {
				EDU15P_TOTAL: { label: "Population 15+ (total)", category: "Population" },
				POP_0_4: { label: "Population aged 0‚Äì4", category: "Population" },
				POP_100_PLUS: { label: "Population aged 100+", category: "Population" },
				EDU_PRIM_OR_LOWER: { label: "Primary or lower education", category: "Education" },
				EDU_LOWER_SECONDARY: { label: "Lower secondary education", category: "Education" },
				EDU_UPPERSEC_POSTSEC_NS: { label: "Upper secondary & postsec non-tertiary", category: "Education" },
				EDU_TERTIARY: { label: "Tertiary education", category: "Education" },
				GROSS_INC_HH: { label: "Gross income per household (‚Ç¨)", category: "Income" },
				GROSS_INC_PC: { label: "Gross income per person (‚Ç¨)", category: "Income" },
				NET_INC_HH: { label: "Net income per household (‚Ç¨)", category: "Income" },
				NET_INC_PC: { label: "Net income per person (‚Ç¨)", category: "Income" },
				MED_INC_EQ: { label: "Median equivalised net income (‚Ç¨)", category: "Income" },
				NET_INC_EQ: { label: "Mean equivalised net income (‚Ç¨)", category: "Income" }
			};
			
			// Filter and map data
			const filteredData = rows.filter(r => indicatorMap[r.indicator_code])
				.map(r => ({ ...r, ...indicatorMap[r.indicator_code] }));
			
			// Store data globally for chart rendering
			demographicsData = filteredData;
			
			if (filteredData.length === 0) {
				console.log('No matching demographics indicators found');
				return;
			}
			
			// 1. Update Population KPI
			const popTotal = filteredData.find(d => d.indicator_code === 'EDU15P_TOTAL');
			const popTotalElement = document.getElementById('popTotal');
			if (popTotal && popTotalElement) {
				popTotalElement.textContent = popTotal.value ? popTotal.value.toLocaleString() : '-';
			}
			
			// 2. Render Education Stacked Bar Chart (from secc_stats)
			if (window.lastApiResponse && window.lastApiResponse.data && window.lastApiResponse.data.secc_stats && window.lastApiResponse.data.secc_stats.rows) {
				console.log('Rendering education chart with SeccStats data');
				renderEducationStackedChart(window.lastApiResponse.data.secc_stats.rows);
				
				// Render Income Distribution Bar Chart
				console.log('Rendering income distribution chart with SeccStats data');
				renderIncomeDistributionChart(window.lastApiResponse.data.secc_stats.rows);
			} else {
				console.log('No secc_stats data available for education chart');
			}
			
			// 3. Calculate and Render Weighted Income by Section
			if (window.lastApiResponse && window.lastApiResponse.data && window.lastApiResponse.data.secc_stats && window.lastApiResponse.data.secc_stats.rows) {
				console.log('Calculating weighted income by section...');
				calculateWeightedIncomeBySection(window.lastApiResponse.data.secc_stats.rows);
			} else {
				console.log('No secc_stats data available for weighted income calculation, using fallback');
			renderIncomeClusteredChart(filteredData);
			}
			
			// 3.5. Render Income Distribution Map (from secc_stats)
			if (window.lastApiResponse && window.lastApiResponse.data && window.lastApiResponse.data.secc_stats && window.lastApiResponse.data.secc_stats.rows) {
				renderIncomeMap(window.lastApiResponse.data.secc_stats.rows);
			} else {
				console.log('No secc_stats data available for income map');
			}
			
			// 4. Render Gender Chart (from secc_stats - gender data is section-level)
			if (window.lastApiResponse && window.lastApiResponse.data && window.lastApiResponse.data.secc_stats && window.lastApiResponse.data.secc_stats.rows) {
				console.log('Rendering gender chart with SeccStats data');
				renderGenderChart(window.lastApiResponse.data.secc_stats.rows);
			} else {
				console.log('No secc_stats data available for gender chart');
			}
			
			// 5. Render Ethnicity & Nationality Chart (from secc_stats)
			if (window.lastApiResponse && window.lastApiResponse.data && window.lastApiResponse.data.secc_stats && window.lastApiResponse.data.secc_stats.rows) {
				renderEthnicityChart(window.lastApiResponse.data.secc_stats.rows);
				renderMigrationChart(window.lastApiResponse.data.secc_stats.rows);
				
				// Render age distribution chart based on current mode
				renderAgeDistributionChartWithMode(window.lastApiResponse.data.secc_stats.rows);
			} else {
				console.log('No secc_stats data available for ethnicity charts');
			}
			
			console.log(`Rendered demographics charts with ${filteredData.length} indicators`);
		}

		// Global variable to track current view mode
		let isChartView = false;
		
		// Global variable to track age distribution view mode
		let isAgeRadiusView = true; // true = radius view, false = section view

		// Function to generate area summary
		function generateAreaSummary(data) {
			const summaryElement = document.getElementById('summaryText');
			if (!summaryElement) return;

			// For now, create a dummy summary - in the future this will use AI API
			const dummySummary = generateDummySummary(data);
			summaryElement.innerHTML = dummySummary;
		}

		// Function to generate dummy summary (placeholder for AI)
		function generateDummySummary(data) {
			// Extract comprehensive metrics from the data
			const metrics = extractAreaMetrics(data);
			
			// Generate rich, detailed summary
			let summary = generateRichSummary(metrics);
			
			return summary;
		}

		// Function to extract comprehensive area metrics
		function extractAreaMetrics(data) {
			const seccData = data?.data?.secc_stats?.rows || [];
			const muniData = data?.data?.muni_stats?.rows || [];
			const properties = data?.data?.properties?.rows || [];
			
			return {
				// Population metrics
				population: seccData.find(r => r.indicator_code === 'POP_TOTAL')?.value || 0,
				avgAge: muniData.find(r => r.indicator_code === 'AGE_MEAN')?.value || 0,
				
				// Economic indicators
				incomePerCapita: seccData.find(r => r.indicator_code === 'GROSS_INC_PC')?.value || 0,
				householdIncome: seccData.find(r => r.indicator_code === 'GROSS_INC_HH')?.value || 0,
				medianIncome: seccData.find(r => r.indicator_code === 'MED_INC_EQ')?.value || 0,
				
				// Education levels
				tertiaryEducation: seccData.filter(r => r.indicator_code === 'EDU_TERTIARY').reduce((sum, r) => sum + (r.value || 0), 0),
				primaryEducation: seccData.filter(r => r.indicator_code === 'EDU_PRIM_OR_LOWER').reduce((sum, r) => sum + (r.value || 0), 0),
				
				// Age distribution
				children: seccData.filter(r => ['POP_0_4', 'POP_5_9', 'POP_10_14'].includes(r.indicator_code)).reduce((sum, r) => sum + (r.value || 0), 0),
				youth: seccData.filter(r => ['POP_15_19', 'POP_20_24'].includes(r.indicator_code)).reduce((sum, r) => sum + (r.value || 0), 0),
				seniors: seccData.filter(r => r.indicator_code?.startsWith('POP_6') || r.indicator_code?.startsWith('POP_7') || r.indicator_code?.startsWith('POP_8') || r.indicator_code?.startsWith('POP_9') || r.indicator_code === 'POP_100_PLUS').reduce((sum, r) => sum + (r.value || 0), 0),
				
				// Migration patterns
				foreignBorn: seccData.find(r => r.indicator_code === 'POP_BIRTHRES_FOREIGN')?.value || 0,
				sameMunicipality: seccData.find(r => r.indicator_code === 'POP_BIRTHRES_ES_SAME_PROV_SAME_MUNI')?.value || 0,
				
				// Property market
				propertyCount: properties.length,
				avgPrice: properties.reduce((sum, p) => sum + (p.price_amount || 0), 0) / properties.length || 0,
				avgPricePerSqm: properties.reduce((sum, p) => sum + (p.price_per_sqm || 0), 0) / properties.length || 0,
				
				// Infrastructure
				infrastructure: data?.data?.infrastructure?.rows || []
			};
		}

		// Function to generate rich, detailed summary
		function generateRichSummary(metrics) {
			let summary = '';
			
			// Population and demographic overview
			summary += `This area presents a ${getPopulationSize(metrics.population)} community of ${metrics.population.toLocaleString()} residents, `;
			summary += `characterized by a ${getAgeProfile(metrics.avgAge)} demographic structure with an average age of ${metrics.avgAge} years. `;
			
			// Economic analysis
			if (metrics.incomePerCapita > 0) {
				summary += `Economically, the area demonstrates ${getEconomicProfile(metrics.incomePerCapita)} indicators with `;
				summary += `per-capita income of ‚Ç¨${metrics.incomePerCapita.toLocaleString()}, `;
				if (metrics.householdIncome > 0) {
					summary += `household income averaging ‚Ç¨${metrics.householdIncome.toLocaleString()}, `;
				}
			}
			
			// Education and workforce analysis
			const educationLevel = getEducationProfile(metrics.tertiaryEducation, metrics.primaryEducation, metrics.population);
			summary += `reflecting a ${educationLevel} workforce profile. `;
			
			// Age distribution insights
			const ageDistribution = getAgeDistributionInsights(metrics);
			summary += ageDistribution;
			
			// Migration and diversity
			if (metrics.foreignBorn > 0) {
				const diversityLevel = (metrics.foreignBorn / metrics.population) * 100;
				summary += `The area shows ${getDiversityLevel(diversityLevel)} with ${diversityLevel.toFixed(1)}% foreign-born residents, `;
			}
			
			// Property market analysis
			if (metrics.propertyCount > 0) {
				summary += `indicating ${getMarketActivity(metrics.propertyCount)} real estate activity. `;
				if (metrics.avgPrice > 0) {
					summary += `Property values average ‚Ç¨${metrics.avgPrice.toLocaleString()}, `;
					if (metrics.avgPricePerSqm > 0) {
						summary += `with price per square meter at ‚Ç¨${metrics.avgPricePerSqm.toLocaleString()}, `;
					}
				}
			}
			
			// Infrastructure assessment
			const infrastructureInsights = getInfrastructureInsights(metrics.infrastructure);
			summary += infrastructureInsights;
			
			// Investment potential and conclusion
			summary += `This location presents ${getInvestmentPotential(metrics)} for both residential and commercial development, `;
			summary += `making it ${getAreaRecommendation(metrics)} for potential investors and residents seeking ${getLifestyleBenefits(metrics)}.`;
			
			return summary;
		}

		// Enhanced helper functions for rich analysis
		function getPopulationSize(population) {
			if (population > 10000) return 'substantial urban';
			if (population > 5000) return 'moderate-sized';
			if (population > 1000) return 'compact residential';
			return 'intimate community';
		}

		function getAgeProfile(avgAge) {
			if (avgAge < 35) return 'youthful and dynamic';
			if (avgAge > 55) return 'mature and established';
			return 'balanced intergenerational';
		}

		function getEconomicProfile(income) {
			if (income > 35000) return 'robust economic';
			if (income > 25000) return 'solid economic';
			if (income > 15000) return 'developing economic';
			return 'emerging economic';
		}

		function getEducationProfile(tertiary, primary, population) {
			if (population === 0) return 'mixed educational';
			const tertiaryRate = (tertiary / population) * 100;
			const primaryRate = (primary / population) * 100;
			
			if (tertiaryRate > 30) return 'highly educated professional';
			if (tertiaryRate > 20) return 'well-educated skilled';
			if (primaryRate > 40) return 'traditional workforce';
			return 'diverse educational';
		}

		function getAgeDistributionInsights(metrics) {
			if (metrics.population === 0) return '';
			
			const childrenRate = (metrics.children / metrics.population) * 100;
			const youthRate = (metrics.youth / metrics.population) * 100;
			const seniorRate = (metrics.seniors / metrics.population) * 100;
			
			let insights = '';
			if (childrenRate > 20) insights += 'The area shows strong family appeal with a high proportion of young families, ';
			if (youthRate > 15) insights += 'indicating vibrant youth presence and potential for growth, ';
			if (seniorRate > 25) insights += 'reflecting a stable, established community with mature demographics, ';
			
			return insights;
		}

		function getDiversityLevel(percentage) {
			if (percentage > 20) return 'significant cultural diversity';
			if (percentage > 10) return 'moderate multicultural character';
			return 'traditional local character';
		}

		function getMarketActivity(count) {
			if (count > 20) return 'high real estate activity';
			if (count > 10) return 'moderate market activity';
			if (count > 5) return 'steady property movement';
			return 'limited market presence';
		}

		function getInfrastructureInsights(infrastructure) {
			if (!infrastructure || infrastructure.length === 0) return '';
			
			const schools = infrastructure.filter(i => i.indicator_name?.toLowerCase().includes('school') || i.indicator_name?.toLowerCase().includes('education')).length;
			const healthcare = infrastructure.filter(i => i.indicator_name?.toLowerCase().includes('hospital') || i.indicator_name?.toLowerCase().includes('health')).length;
			const commercial = infrastructure.filter(i => i.indicator_name?.toLowerCase().includes('shop') || i.indicator_name?.toLowerCase().includes('market')).length;
			
			let insights = 'The area benefits from ';
			const services = [];
			if (schools > 0) services.push(`${schools} educational facilities`);
			if (healthcare > 0) services.push(`${healthcare} healthcare services`);
			if (commercial > 0) services.push(`${commercial} commercial establishments`);
			
			if (services.length > 0) {
				insights += services.join(', ') + ', ';
			} else {
				insights += 'essential community services, ';
			}
			
			return insights;
		}

		function getInvestmentPotential(metrics) {
			const factors = [];
			if (metrics.population > 1000) factors.push('strong demographic base');
			if (metrics.incomePerCapita > 25000) factors.push('solid economic foundation');
			if (metrics.propertyCount > 10) factors.push('active property market');
			if (metrics.avgAge < 45) factors.push('growth potential');
			
			if (factors.length === 0) return 'moderate investment opportunities';
			return factors.join(', ') + ' creating significant investment potential';
		}

		function getAreaRecommendation(metrics) {
			if (metrics.incomePerCapita > 30000 && metrics.population > 2000) return 'an attractive destination';
			if (metrics.avgAge < 40 && metrics.propertyCount > 15) return 'a promising opportunity';
			if (metrics.population > 1000) return 'a viable option';
			return 'a niche market';
		}

		function getLifestyleBenefits(metrics) {
			const benefits = [];
			if (metrics.avgAge < 40) benefits.push('dynamic urban living');
			if (metrics.incomePerCapita > 25000) benefits.push('affordable quality of life');
			if (metrics.population > 2000) benefits.push('community amenities');
			benefits.push('strategic location advantages');
			
			return benefits.join(' and ');
		}

		// Function to render income distribution bar chart
		function renderIncomeDistributionChart(seccStatsRows) {
			console.log('[Income Distribution] Processing income data from SeccStats rows:', seccStatsRows.length);
			
			// First, get population data (POP_TOTAL) for each section by area_name/secc_area_name
			const sectionPopulations = {};
			const popTotalRows = seccStatsRows.filter(r => 
				r.indicator_code === 'POP_TOTAL' && 
				r.value && 
				(r.secc_area_name || r.area_name)
			);
			
			popTotalRows.forEach(row => {
				const areaName = row.secc_area_name || row.area_name;
				if (areaName) {
					const popValue = parseInt(row.value) || 0;
					if (popValue > 0) {
						// If multiple entries for same area, sum them
						sectionPopulations[areaName] = (sectionPopulations[areaName] || 0) + popValue;
					}
				}
			});
			
			console.log(`[Income Distribution] Found population data for ${Object.keys(sectionPopulations).length} sections`);
			console.log('[Income Distribution] Sample section populations:', Object.entries(sectionPopulations).slice(0, 5));
			
			// Calculate total population
			const totalPopulation = Object.values(sectionPopulations).reduce((sum, pop) => sum + pop, 0);
			console.log(`[Income Distribution] Total population: ${totalPopulation.toLocaleString()}`);
			
			// Income indicators to filter by indicator_name
			const incomeIndicators = [
				'Gross income per household',
				'Gross income per person',
				'Mean equivalised net income',
				'Median equivalised net income',
				'Net income per household',
				'Net income per person'
			];
			
			// Calculate weighted averages for each income indicator
			const incomeWeightedAverages = {};
			
			incomeIndicators.forEach(indicatorName => {
				// Filter rows by indicator_name (case-insensitive match)
				const matchingRows = seccStatsRows.filter(r => {
					const rowIndicatorName = r.indicator_name ? r.indicator_name.trim() : '';
					return rowIndicatorName.toLowerCase() === indicatorName.toLowerCase() && 
						   r.value && 
						   (r.secc_area_name || r.area_name);
				});
				
				// Calculate weighted average: sum(income_value * population) / sum(population)
				let totalWeightedIncome = 0;
				let totalPopulationForIndicator = 0;
				const sectionsWithData = new Set();
				
				matchingRows.forEach(row => {
					const areaName = row.secc_area_name || row.area_name;
					const incomeValue = parseFloat(row.value) || 0;
					const sectionPopulation = sectionPopulations[areaName] || 0;
					
					if (incomeValue > 0 && sectionPopulation > 0) {
						totalWeightedIncome += incomeValue * sectionPopulation;
						totalPopulationForIndicator += sectionPopulation;
						sectionsWithData.add(areaName);
					}
				});
				
				const weightedAverage = totalPopulationForIndicator > 0 
					? totalWeightedIncome / totalPopulationForIndicator 
					: 0;
				
				// Store weighted average and metadata
				incomeWeightedAverages[indicatorName] = {
					weightedAverage: weightedAverage,
					sectionCount: sectionsWithData.size,
					totalPopulation: totalPopulationForIndicator,
					rowCount: matchingRows.length
				};
				
				console.log(`[Income Distribution] ${indicatorName}:`);
				console.log(`  Weighted Average: ‚Ç¨${weightedAverage.toLocaleString()}`);
				console.log(`  Sections: ${sectionsWithData.size}`);
				console.log(`  Population used: ${totalPopulationForIndicator.toLocaleString()}`);
			});
			
			// Check if we have any income data
			const hasData = Object.values(incomeWeightedAverages).some(data => data.weightedAverage > 0);
			if (!hasData) {
				console.log('[Income Distribution] No income data available for chart');
				return;
			}
			
			const ctx = document.getElementById('incomeDistributionChart');
			
			if (!ctx) {
				console.log('[Income Distribution] Income distribution chart canvas not found');
				return;
			}
			
			// Destroy existing chart if it exists
			if (window.incomeDistributionChartInstance) {
				window.incomeDistributionChartInstance.destroy();
				window.incomeDistributionChartInstance = null;
			}
			
			// Prepare data for grouped bar chart - split Gross and Net Income (using weighted averages)
			const chartData = {
				labels: ['Per Household', 'Per Person'],
				datasets: [
					{
						label: 'Gross Income',
						data: [
							incomeWeightedAverages['Gross income per household']?.weightedAverage || 0,
							incomeWeightedAverages['Gross income per person']?.weightedAverage || 0
						],
						backgroundColor: ['#4E79A7', '#6B9BD2'],
						borderColor: ['#3D5A7F', '#5A7BB2'],
						borderWidth: 2,
						hoverBorderWidth: 3
					},
					{
						label: 'Net Income',
						data: [
							incomeWeightedAverages['Net income per household']?.weightedAverage || 0,
							incomeWeightedAverages['Net income per person']?.weightedAverage || 0
						],
						backgroundColor: ['#F28E2B', '#F5A461'],
						borderColor: ['#E27E1B', '#E59451'],
						borderWidth: 2,
						hoverBorderWidth: 3
					},
					{
						label: 'Mean Equivalised Net Income',
						data: [
							incomeWeightedAverages['Mean equivalised net income']?.weightedAverage || 0,
							0 // No per person data
						],
						backgroundColor: ['#76B7B2', '#76B7B2'],
						borderColor: ['#6697A2', '#6697A2'],
						borderWidth: 2,
						hoverBorderWidth: 3
					},
					{
						label: 'Median Equivalised Net Income',
						data: [
							incomeWeightedAverages['Median equivalised net income']?.weightedAverage || 0,
							0 // No per person data
						],
						backgroundColor: ['#E15759', '#E15759'],
						borderColor: ['#D14749', '#D14749'],
						borderWidth: 2,
						hoverBorderWidth: 3
					}
				]
			};
			
			const config = {
				type: 'bar',
				data: chartData,
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							display: true,
							position: 'bottom',
							labels: {
								padding: 10,
								usePointStyle: true,
								font: {
									size: 11
								}
							}
						},
						title: {
							display: true,
							text: `Income Distribution - Weighted Average (${totalPopulation.toLocaleString()} people, ${Object.keys(sectionPopulations).length} sections)`,
							font: {
								size: 14,
								weight: 'bold'
							},
							padding: {
								top: 10,
								bottom: 10
							}
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const value = context.parsed.y;
									if (value === 0) return null;
									
									const datasetLabel = context.dataset.label;
									const labelIndex = context.dataIndex;
									const indicatorNames = {
										'Gross Income': ['Gross income per household', 'Gross income per person'],
										'Net Income': ['Net income per household', 'Net income per person'],
										'Mean Equivalised Net Income': ['Mean equivalised net income', null],
										'Median Equivalised Net Income': ['Median equivalised net income', null]
									};
									
									const indicatorName = indicatorNames[datasetLabel]?.[labelIndex];
									if (!indicatorName) return `${datasetLabel}: ‚Ç¨${value.toLocaleString()}`;
									
									const incomeData = incomeWeightedAverages[indicatorName];
									const sectionCount = incomeData?.sectionCount || 0;
									const popUsed = incomeData?.totalPopulation || 0;
									return `${datasetLabel}: ‚Ç¨${value.toLocaleString()} (${sectionCount} sections, ${popUsed.toLocaleString()} people)`;
								}
							}
						}
					},
					scales: {
						y: {
							beginAtZero: true,
							ticks: {
								callback: function(value) {
									return '‚Ç¨' + value.toLocaleString();
								}
							},
							title: {
								display: true,
								text: 'Income (‚Ç¨)',
								font: {
									size: 12,
									weight: 'bold'
								}
							}
						},
						x: {
							ticks: {
								font: {
									size: 11
								}
							},
							grid: {
								display: false
							}
						}
					}
				}
			};
			
			try {
				if (typeof Chart === 'undefined') {
					console.error('[Income Distribution] Chart.js library not loaded');
					return;
				}
				
				window.incomeDistributionChartInstance = new Chart(ctx, config);
				console.log('[Income Distribution] ‚úÖ Chart created successfully');
			} catch (error) {
				console.error('[Income Distribution] ‚ùå Error creating chart:', error);
			}
		}

		// Function to render education stacked bar chart
		function renderEducationStackedChart(seccStatsRows) {
			console.log('Processing education data from SeccStats rows:', seccStatsRows);
			
			// Filter and sum education data from SeccStats
			const primaryData = seccStatsRows.filter(r => r.indicator_name === 'Primary or lower education' && r.value);
			const lowerSecondaryData = seccStatsRows.filter(r => r.indicator_name === 'Lower secondary education' && r.value);
			const upperSecondaryData = seccStatsRows.filter(r => r.indicator_name === 'Upper secondary & postsec non-tertiary' && r.value);
			const tertiaryData = seccStatsRows.filter(r => r.indicator_name === 'Tertiary education' && r.value);
			
			// Sum values from all sections for each education category
			const primaryTotal = primaryData.reduce((sum, item) => sum + parseInt(item.value), 0);
			const lowerSecondaryTotal = lowerSecondaryData.reduce((sum, item) => sum + parseInt(item.value), 0);
			const upperSecondaryTotal = upperSecondaryData.reduce((sum, item) => sum + parseInt(item.value), 0);
			const tertiaryTotal = tertiaryData.reduce((sum, item) => sum + parseInt(item.value), 0);
			
			console.log('Education data from SeccStats:');
			console.log(`Primary or lower: ${primaryTotal} (${primaryData.length} sections)`);
			console.log(`Lower secondary: ${lowerSecondaryTotal} (${lowerSecondaryData.length} sections)`);
			console.log(`Upper secondary & postsec: ${upperSecondaryTotal} (${upperSecondaryData.length} sections)`);
			console.log(`Tertiary: ${tertiaryTotal} (${tertiaryData.length} sections)`);
			
			const totalEducation = primaryTotal + lowerSecondaryTotal + upperSecondaryTotal + tertiaryTotal;
			
			if (totalEducation === 0) {
				console.log('No education data available for chart');
				return;
			}

			const ctx = document.getElementById('educationChart');
			
			if (!ctx) {
				console.log('Education chart canvas not found');
				return;
			}
			
			// Destroy existing chart if it exists
			if (window.educationChartInstance) {
				window.educationChartInstance.destroy();
			}

			// Prepare data for donut chart
			const chartData = {
				labels: ["Primary or lower", "Lower secondary", "Upper secondary & postsec", "Tertiary"],
				datasets: [{
					data: [
						primaryTotal,
						lowerSecondaryTotal,
						upperSecondaryTotal,
						tertiaryTotal
					],
					backgroundColor: [
						"#A7D3A6",
						"#6FB06C", 
						"#3D8141",
						"#1F5A27"
					],
					borderColor: [
						"#A7D3A6",
						"#6FB06C",
						"#3D8141", 
						"#1F5A27"
					],
					borderWidth: 2,
					hoverBorderWidth: 3
				}]
			};

			const config = {
				type: 'doughnut',
				data: chartData,
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							position: 'bottom',
							labels: {
								padding: 10,
								usePointStyle: true,
								font: {
									size: 11
								},
								generateLabels: function(chart) {
									const data = chart.data;
									if (data.labels.length && data.datasets.length) {
										return data.labels.map((label, i) => {
											const dataset = data.datasets[0];
											const value = dataset.data[i];
											const total = dataset.data.reduce((a, b) => a + b, 0);
											const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
											return {
												text: `${label} ${percentage}%`,
												fillStyle: dataset.backgroundColor[i],
												strokeStyle: dataset.borderColor[i],
												lineWidth: dataset.borderWidth,
												pointStyle: 'circle',
												hidden: false,
												index: i
											};
										});
									}
									return [];
								}
							}
						},
						title: {
							display: true,
							text: 'Education Breakdown',
							font: {
								size: 14,
								weight: 'bold'
							}
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const label = context.label || '';
									const value = context.parsed;
									const total = context.dataset.data.reduce((a, b) => a + b, 0);
									const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
									return `${label}: ${value.toLocaleString()} (${percentage}%)`;
								}
							}
						},
						datalabels: {
							display: true,
							color: '#ffffff',
							font: {
								size: 12,
								weight: 'bold'
							},
							formatter: function(value, context) {
								const total = context.dataset.data.reduce((a, b) => a + b, 0);
								const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
								return percentage + '%';
							}
						}
					},
					cutout: '60%', // Makes it a donut chart
					animation: {
						animateRotate: true,
						animateScale: true
					}
				}
			};

			// Create new chart
			window.educationChartInstance = new Chart(ctx, config);
		}

		// Function to find coordinates for a census section from Properties data
		function findSectionCoordinates(seccAreaName, propertiesData) {
			if (!propertiesData || !propertiesData.rows) {
				console.log('No properties data available for coordinate lookup');
				return null;
			}

			// Try to find a property that matches the census section
			const matchingProperty = propertiesData.rows.find(property => {
				// Check if property has seccion_name field and it matches
				if (property.seccion_name && property.seccion_name === seccAreaName) {
					return true;
				}
				
				// Alternative: check if location_optimized contains the section name
				if (property.location_optimized && property.location_optimized.includes(seccAreaName)) {
					return true;
				}
				
				// Alternative: check if location contains the section name
				if (property.location && property.location.includes(seccAreaName)) {
					return true;
				}
				
				return false;
			});

			if (matchingProperty && matchingProperty.latitude && matchingProperty.longitude) {
				console.log(`Found coordinates for ${seccAreaName}:`, {
					lat: matchingProperty.latitude,
					lon: matchingProperty.longitude
				});
				return {
					lat: parseFloat(matchingProperty.latitude),
					lon: parseFloat(matchingProperty.longitude)
				};
			}

			console.log(`No coordinates found for census section: ${seccAreaName}`);
			return null;
		}

		// Function to render income distribution choropleth map
		function renderIncomeMap(rows) {
			const mapContainer = document.getElementById('incomeMap');
			if (!mapContainer) {
				console.log('Income map container not found');
				return;
			}

			// Clear existing map
			mapContainer.innerHTML = '';

			// Extract income data from secc_stats - filter by indicator_name
			const incomeData = rows.filter(row => {
				const rowIndicatorName = row.indicator_name ? row.indicator_name.trim() : '';
				return rowIndicatorName.toLowerCase() === 'net income per person' && 
					   row.value && 
					   (row.secc_area_name || row.area_name) &&
					   !row.municipio_area_name;
			});

			if (incomeData.length === 0) {
				mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">No income data available for mapping</div>';
				return;
			}

			console.log('Income data for map:', incomeData);

			// Get properties data for coordinate lookup
			const propertiesData = window.lastApiResponse?.data?.properties;
			console.log('Properties data for coordinate lookup:', propertiesData);

			// Calculate income quantiles for color scale
			const incomes = incomeData.map(d => d.value).sort((a, b) => a - b);
			const quantiles = {
				q20: incomes[Math.floor(incomes.length * 0.2)],
				q40: incomes[Math.floor(incomes.length * 0.4)],
				q60: incomes[Math.floor(incomes.length * 0.6)],
				q80: incomes[Math.floor(incomes.length * 0.8)]
			};

			console.log('Income quantiles:', quantiles);

			// Color scale function
			function getIncomeColor(income) {
				if (income >= quantiles.q80) return '#2E7D32'; // Very High - Dark Green
				if (income >= quantiles.q60) return '#81C784'; // High - Light Green
				if (income >= quantiles.q40) return '#FFF176'; // Medium - Yellow
				if (income >= quantiles.q20) return '#FB8C00'; // Low - Orange
				return '#E53935'; // Very Low - Red
			}

			// Get income level description
			function getIncomeLevel(income) {
				if (income >= quantiles.q80) return 'Very High';
				if (income >= quantiles.q60) return 'High';
				if (income >= quantiles.q40) return 'Medium';
				if (income >= quantiles.q20) return 'Low';
				return 'Very Low';
			}

			// Try to get search center from AppState or global variable
			let mapCenter = [40.4168, -3.7038]; // Default to Madrid
			let mapZoom = 13;
			
			// Check for search center from AppState
			if (window.AppState) {
				const searchCenter = window.AppState.getSearchCenter();
				if (searchCenter && searchCenter.lat && searchCenter.lon) {
					mapCenter = [parseFloat(searchCenter.lat), parseFloat(searchCenter.lon)];
					console.log('[Income Map] Using search center from AppState:', mapCenter);
				}
			}
			
			// Also check global searchCenter variable (fallback)
			if (typeof searchCenter !== 'undefined' && searchCenter && searchCenter.lat && searchCenter.lon) {
				mapCenter = [parseFloat(searchCenter.lat), parseFloat(searchCenter.lon)];
				console.log('[Income Map] Using global search center:', mapCenter);
			}

			// Initialize map
			const map = L.map('incomeMap').setView(mapCenter, mapZoom);

			// Add tile layer
			L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				attribution: '¬© OpenStreetMap contributors'
			}).addTo(map);

			// Store all markers with valid coordinates to fit bounds later
			const markersWithValidCoords = [];
			
			// Create markers for each census section
			incomeData.forEach(section => {
				const areaName = section.secc_area_name || section.area_name;
				// Try to find real coordinates from Properties data
				const coords = findSectionCoordinates(areaName, propertiesData);
				
				let lat, lon;
				let hasValidCoords = false;
				if (coords) {
					// Use real coordinates
					lat = coords.lat;
					lon = coords.lon;
					hasValidCoords = true;
					console.log(`Using real coordinates for ${areaName}:`, coords);
				} else {
					// Fallback to approximate coordinates around map center
					lat = mapCenter[0] + (Math.random() - 0.5) * 0.01;
					lon = mapCenter[1] + (Math.random() - 0.5) * 0.01;
					console.log(`Using approximate coordinates for ${areaName}:`, { lat, lon });
				}
				
				const income = parseFloat(section.value) || 0;
				const color = getIncomeColor(income);
				const level = getIncomeLevel(income);

				// Create circle marker
				const marker = L.circleMarker([lat, lon], {
					radius: 8,
					fillColor: color,
					color: '#fff',
					weight: 2,
					opacity: 1,
					fillOpacity: 0.8
				}).addTo(map);

				// Add popup with income details
				marker.bindPopup(`
					<div style="min-width: 200px;">
						<h6 style="margin: 0 0 8px 0; color: #333;">${areaName}</h6>
						<div style="margin-bottom: 4px;">
							<strong>Net Income per Person:</strong> ‚Ç¨${income.toLocaleString()}
						</div>
						<div style="margin-bottom: 4px;">
							<strong>Income Level:</strong> ${level}
						</div>
						${section.year ? `<div style="margin-bottom: 4px;"><strong>Year:</strong> ${section.year}</div>` : ''}
						${section.source ? `<div style="margin-bottom: 4px;"><strong>Source:</strong> ${section.source}</div>` : ''}
						<div style="margin-bottom: 4px;">
							<strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lon.toFixed(6)}
						</div>
					</div>
				`);
				
				// Store marker for bounds calculation (only if it has valid coordinates)
				if (hasValidCoords) {
					markersWithValidCoords.push(marker);
				}
			});
			
			// Fit map bounds to show all markers if we have any with valid coordinates
			if (markersWithValidCoords.length > 0) {
				const group = new L.featureGroup(markersWithValidCoords);
				map.fitBounds(group.getBounds().pad(0.1), { maxZoom: 15 });
				console.log('[Income Map] Fitted bounds to', markersWithValidCoords.length, 'markers with valid coordinates');
			} else if (markersWithValidCoords.length === 0 && (mapCenter[0] !== 40.4168 || mapCenter[1] !== -3.7038)) {
				// If no valid coordinates but we have a search center, zoom to it
				map.setView(mapCenter, 13);
				console.log('[Income Map] No markers with valid coordinates, zoomed to search center:', mapCenter);
			} else {
				console.log('[Income Map] Using default map center');
			}

			// Add legend
			const legend = L.control({position: 'bottomright'});
			legend.onAdd = function(map) {
				const div = L.DomUtil.create('div', 'info legend');
				div.style.background = 'white';
				div.style.padding = '10px';
				div.style.borderRadius = '5px';
				div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
				
				const levels = [
					{min: quantiles.q80, max: Infinity, color: '#2E7D32', label: 'Very High'},
					{min: quantiles.q60, max: quantiles.q80, color: '#81C784', label: 'High'},
					{min: quantiles.q40, max: quantiles.q60, color: '#FFF176', label: 'Medium'},
					{min: quantiles.q20, max: quantiles.q40, color: '#FB8C00', label: 'Low'},
					{min: 0, max: quantiles.q20, color: '#E53935', label: 'Very Low'}
				];

				let legendHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Income Levels (‚Ç¨)</div>';
				levels.forEach(level => {
					const minText = level.min === 0 ? '0' : level.min.toLocaleString();
					const maxText = level.max === Infinity ? '‚àû' : level.max.toLocaleString();
					legendHTML += `
						<div style="margin: 2px 0;">
							<span style="display: inline-block; width: 12px; height: 12px; background: ${level.color}; margin-right: 5px; border-radius: 2px;"></span>
							${level.label}: ‚Ç¨${minText} - ‚Ç¨${maxText}
						</div>
					`;
				});
				
				div.innerHTML = legendHTML;
				return div;
			};
			legend.addTo(map);

			// Store map reference for cleanup
			window.incomeMapInstance = map;
		}

		// Function to calculate weighted average income by Secc_area_name
		// Uses POP_TOTAL for population and income indicators from SeccStats
		function calculateWeightedIncomeBySection(rows) {
			console.log('[Income] === CALCULATING WEIGHTED INCOME BY SECTION ===');
			console.log('[Income] Total rows:', rows.length);
			
			if (!rows || rows.length === 0) {
				console.error('[Income] ‚ùå No rows provided');
				return null;
			}
			
			// Group data by Secc_area_name
			const sectionGroups = {};
			
			rows.forEach(row => {
				if (row.secc_area_name && !row.municipio_area_name) {
					if (!sectionGroups[row.secc_area_name]) {
						sectionGroups[row.secc_area_name] = {
							population: 0,
							incomeData: {}
						};
					}
					
					// Sum population for each section (POP_TOTAL)
					if (row.indicator_code === 'POP_TOTAL' && row.value) {
						const popValue = parseInt(row.value) || 0;
						sectionGroups[row.secc_area_name].population += popValue;
					}
					
					// Store income indicators
					const incomeIndicators = ['GROSS_INC_HH', 'GROSS_INC_PC', 'NET_INC_HH', 'NET_INC_PC', 'MED_INC_EQ', 'NET_INC_EQ'];
					if (incomeIndicators.includes(row.indicator_code) && row.value) {
						const incomeValue = parseFloat(row.value) || 0;
						sectionGroups[row.secc_area_name].incomeData[row.indicator_code] = incomeValue;
					}
				}
			});
			
			console.log('[Income] Section groups created:', Object.keys(sectionGroups).length, 'sections');
			console.log('[Income] Sample section groups:', Object.entries(sectionGroups).slice(0, 3));
			
			// Check if we have data
			const totalPopulation = Object.values(sectionGroups).reduce((sum, data) => sum + data.population, 0);
			if (totalPopulation === 0) {
				console.error('[Income] ‚ùå No population data found (POP_TOTAL)');
				return null;
			}
			
			console.log('[Income] Total population across all sections:', totalPopulation);
			
			// Calculate weighted averages for each income indicator
			const weightedResults = {};
			const incomeIndicators = ['GROSS_INC_HH', 'GROSS_INC_PC', 'NET_INC_HH', 'NET_INC_PC', 'MED_INC_EQ', 'NET_INC_EQ'];
			
			incomeIndicators.forEach(indicator => {
				let totalWeightedIncome = 0;
				let totalPopulation = 0;
				let sectionsWithData = 0;
				
				Object.entries(sectionGroups).forEach(([sectionName, data]) => {
					if (data.incomeData[indicator] && data.incomeData[indicator] > 0 && data.population > 0) {
						totalWeightedIncome += data.incomeData[indicator] * data.population;
						totalPopulation += data.population;
						sectionsWithData++;
					}
				});
				
				weightedResults[indicator] = totalPopulation > 0 ? totalWeightedIncome / totalPopulation : 0;
				
				console.log(`[Income] ${indicator}:`, {
					weightedAverage: weightedResults[indicator],
					sections: sectionsWithData,
					totalPopulation: totalPopulation
				});
			});
			
			console.log('[Income] Weighted income results:', weightedResults);
			
			// Validate we have at least some income data
			const hasIncomeData = Object.values(weightedResults).some(value => value > 0);
			if (!hasIncomeData) {
				console.error('[Income] ‚ùå No income data found in any sections');
				console.error('[Income] Available indicator codes:', [...new Set(rows.map(r => r.indicator_code))].slice(0, 20));
				return null;
			}
			
			// Display results in console and create summary
			const summary = {
				totalSections: Object.keys(sectionGroups).length,
				totalPopulation: totalPopulation,
				weightedAverages: weightedResults,
				sectionDetails: sectionGroups
			};
			
			console.log('[Income] ‚úÖ Weighted Income Summary:', {
				totalSections: summary.totalSections,
				totalPopulation: summary.totalPopulation,
				weightedAverages: summary.weightedAverages
			});
			
			// Update the income chart with weighted data
			try {
			renderWeightedIncomeChart(weightedResults, summary);
				console.log('[Income] ‚úÖ Chart rendered successfully');
			} catch (error) {
				console.error('[Income] ‚ùå Error rendering chart:', error);
			}
			
			// Display detailed summary
			displayWeightedIncomeSummary(summary);
			
			return summary;
		}

		// Function to display weighted income summary
		function displayWeightedIncomeSummary(summary) {
			console.log('=== WEIGHTED INCOME SUMMARY ===');
			console.log(`Total Sections: ${summary.totalSections}`);
			console.log(`Total Population: ${summary.totalPopulation.toLocaleString()}`);
			console.log('Weighted Averages:');
			
			Object.entries(summary.weightedAverages).forEach(([indicator, value]) => {
				console.log(`  ${indicator}: ‚Ç¨${value.toLocaleString()}`);
			});
			
			console.log('Section Details:');
			Object.entries(summary.sectionDetails).forEach(([sectionName, data]) => {
				console.log(`  ${sectionName}: Population ${data.population.toLocaleString()}`);
				Object.entries(data.incomeData).forEach(([indicator, value]) => {
					console.log(`    ${indicator}: ‚Ç¨${value.toLocaleString()}`);
				});
			});
			
			// Create a detailed summary display in the console
			const detailedSummary = `
=== WEIGHTED INCOME ANALYSIS ===
Total Census Sections: ${summary.totalSections}
Total Population: ${summary.totalPopulation.toLocaleString()}

WEIGHTED AVERAGE INCOME (‚Ç¨):
‚Ä¢ Gross Income per Household: ‚Ç¨${summary.weightedAverages.GROSS_INC_HH?.toLocaleString() || 'N/A'}
‚Ä¢ Gross Income per Person: ‚Ç¨${summary.weightedAverages.GROSS_INC_PC?.toLocaleString() || 'N/A'}
‚Ä¢ Net Income per Household: ‚Ç¨${summary.weightedAverages.NET_INC_HH?.toLocaleString() || 'N/A'}
‚Ä¢ Net Income per Person: ‚Ç¨${summary.weightedAverages.NET_INC_PC?.toLocaleString() || 'N/A'}
‚Ä¢ Median Equivalised Net Income: ‚Ç¨${summary.weightedAverages.MED_INC_EQ?.toLocaleString() || 'N/A'}
‚Ä¢ Mean Equivalised Net Income: ‚Ç¨${summary.weightedAverages.NET_INC_EQ?.toLocaleString() || 'N/A'}

SECTION BREAKDOWN:
${Object.entries(summary.sectionDetails).map(([sectionName, data]) => `
${sectionName}:
  Population: ${data.population.toLocaleString()}
  Income Data: ${Object.entries(data.incomeData).map(([indicator, value]) => `${indicator}: ‚Ç¨${value.toLocaleString()}`).join(', ')}
`).join('')}
			`;
			
			console.log(detailedSummary);
		}

		// Function to render weighted income chart
		function renderWeightedIncomeChart(weightedData, summary) {
			console.log('[Income] Rendering weighted income chart...');
			
			const ctx = document.getElementById('incomeChart');
			if (!ctx) {
				console.error('[Income] ‚ùå Income chart canvas not found');
				return;
			}
			
			// Destroy existing chart if it exists
			if (window.incomeChartInstance) {
				console.log('[Income] Destroying existing chart instance');
				window.incomeChartInstance.destroy();
				window.incomeChartInstance = null;
			}
			
			// Validate data
			if (!weightedData || Object.keys(weightedData).length === 0) {
				console.error('[Income] ‚ùå No weighted data provided');
				return;
			}
			
			console.log('[Income] Chart data:', {
				GROSS_INC_HH: weightedData['GROSS_INC_HH'],
				GROSS_INC_PC: weightedData['GROSS_INC_PC'],
				NET_INC_HH: weightedData['NET_INC_HH'],
				NET_INC_PC: weightedData['NET_INC_PC'],
				MED_INC_EQ: weightedData['MED_INC_EQ'],
				NET_INC_EQ: weightedData['NET_INC_EQ']
			});

			// Prepare data for clustered chart with weighted averages
			const incomeChartData = {
				labels: ["Household", "Person"],
				datasets: [
					{ 
						label: "Gross Income (Weighted)", 
						data: [
							weightedData['GROSS_INC_HH'] || 0,
							weightedData['GROSS_INC_PC'] || 0
						], 
						backgroundColor: "#4E79A7" 
					},
					{ 
						label: "Net Income (Weighted)", 
						data: [
							weightedData['NET_INC_HH'] || 0,
							weightedData['NET_INC_PC'] || 0
						], 
						backgroundColor: "#F28E2B" 
					},
					{ 
						label: "Median Net Income (Weighted)", 
						data: [
							weightedData['MED_INC_EQ'] || 0,
							0 // No median income per person data
						], 
						backgroundColor: "#E15759" 
					},
					{ 
						label: "Mean Net Income (Weighted)", 
						data: [
							weightedData['NET_INC_EQ'] || 0,
							0 // No mean income per person data
						], 
						backgroundColor: "#76B7B2" 
					}
				]
			};

			console.log('[Income] Chart data prepared:', incomeChartData);

			const incomeConfig = {
				type: "bar",
				data: incomeChartData,
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: { 
							position: "bottom",
							display: true
						},
						title: { 
							display: true, 
							text: `Weighted Income Comparison (‚Ç¨) - ${summary.totalSections} sections, ${summary.totalPopulation.toLocaleString()} people`,
							font: {
								size: 14,
								weight: 'bold'
							}
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const value = context.parsed.y;
									return context.dataset.label + ': ‚Ç¨' + value.toLocaleString();
								}
							}
						}
					},
					scales: {
						y: {
							beginAtZero: true,
							ticks: {
								callback: function(value) {
									return '‚Ç¨' + value.toLocaleString();
								}
							}
						},
						x: {
							grid: {
								display: false
							}
						}
					}
				}
			};

			try {
				// Check if Chart is available
				if (typeof Chart === 'undefined') {
					console.error('[Income] ‚ùå Chart.js library not loaded');
					return;
				}

			// Create new chart
			window.incomeChartInstance = new Chart(ctx, incomeConfig);
				console.log('[Income] ‚úÖ Chart created successfully');
			} catch (error) {
				console.error('[Income] ‚ùå Error creating chart:', error);
				console.error('[Income] Error details:', error.message);
				if (error.stack) {
					console.error('[Income] Stack trace:', error.stack);
				}
			}
		}

		// Function to render income clustered bar chart (original function)
		function renderIncomeClusteredChart(data) {
			// Filter income data
			const incomeData = data.filter(item => item.category === 'Income');
			
			if (incomeData.length === 0) {
				console.log('No income data available for chart');
				return;
			}

			const ctx = document.getElementById('incomeChart').getContext('2d');
			
			// Destroy existing chart if it exists
			if (window.incomeChartInstance) {
				window.incomeChartInstance.destroy();
			}

			// Prepare data for clustered chart
			const incomeChartData = {
				labels: ["Household", "Person"],
				datasets: [
					{ 
						label: "Gross Income", 
						data: [
							incomeData.find(d => d.indicator_code === 'GROSS_INC_HH')?.value || 0,
							incomeData.find(d => d.indicator_code === 'GROSS_INC_PC')?.value || 0
						], 
						backgroundColor: "#4E79A7" 
					},
					{ 
						label: "Net Income", 
						data: [
							incomeData.find(d => d.indicator_code === 'NET_INC_HH')?.value || 0,
							incomeData.find(d => d.indicator_code === 'NET_INC_PC')?.value || 0
						], 
						backgroundColor: "#F28E2B" 
					},
					{ 
						label: "Median Net Income", 
						data: [
							incomeData.find(d => d.indicator_code === 'MED_INC_EQ')?.value || 0,
							0 // No median income per person data
						], 
						backgroundColor: "#E15759" 
					},
					{ 
						label: "Mean Net Income", 
						data: [
							incomeData.find(d => d.indicator_code === 'NET_INC_EQ')?.value || 0,
							0 // No mean income per person data
						], 
						backgroundColor: "#76B7B2" 
					}
				]
			};

			const incomeConfig = {
				type: "bar",
				data: incomeChartData,
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: { position: "bottom" },
						title: { display: true, text: "Income Comparison (‚Ç¨)" }
					},
					scales: {
						y: {
							beginAtZero: true,
							ticks: {
								callback: function(value) {
									return '‚Ç¨' + value.toLocaleString();
								}
							}
						}
					}
				}
			};

			// Create new chart
			window.incomeChartInstance = new Chart(ctx, incomeConfig);
		}

		// Function to render gender composition chart
		function renderGenderChart(rows) {
			const ctx = document.getElementById('genderChart');
			
			if (!ctx) {
				console.log('Gender chart canvas not found');
				return;
			}
			
			// Destroy existing chart if it exists
			if (window.genderChartInstance) {
				window.genderChartInstance.destroy();
			}
			
			// Extract gender data from API
			const genderData = processGenderData(rows);
			
			if (!genderData.hasData) {
				console.warn('[Gender Chart] ‚ùå No gender data available - processGenderData returned hasData: false');
				const summaryEl = document.getElementById('genderSummary');
				if (summaryEl) {
					summaryEl.textContent = 'Gender data is currently unavailable for this area. Check console for details.';
					summaryEl.style.color = '#dc2626';
				}
				// Clear the canvas and show message
				const canvasCtx = ctx.getContext('2d');
				canvasCtx.clearRect(0, 0, ctx.width || 400, ctx.height || 200);
				canvasCtx.fillStyle = '#6b7280';
				canvasCtx.font = '12px Arial';
				canvasCtx.textAlign = 'center';
				canvasCtx.fillText('No gender data available', (ctx.width || 400) / 2, (ctx.height || 200) / 2);
				return;
			}
			
			// Prepare data for donut chart
			const chartData = {
				labels: ["‚ôÇ Male", "‚ôÄ Female"],
				datasets: [{
					data: [genderData.malePercent, genderData.femalePercent],
					backgroundColor: [
						'#4A90E2', // Blue for male
						'#F78DA7'  // Pink for female
					],
					borderColor: [
						'#4A90E2',
						'#F78DA7'
					],
					borderWidth: 2,
					hoverBorderWidth: 3
				}]
			};
			
			const config = {
				type: 'doughnut',
				data: chartData,
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							position: 'bottom',
							labels: {
								padding: 10,
								usePointStyle: true,
								font: {
									size: 11
								},
								generateLabels: function(chart) {
									const data = chart.data;
									if (data.labels.length && data.datasets.length) {
										return data.labels.map((label, i) => {
											const dataset = data.datasets[0];
											const value = dataset.data[i];
											return {
												text: `${label} ${value.toFixed(1)}%`,
												fillStyle: dataset.backgroundColor[i],
												strokeStyle: dataset.borderColor[i],
												lineWidth: dataset.borderWidth,
												pointStyle: 'circle',
												hidden: false,
												index: i
											};
										});
									}
									return [];
								}
							}
						},
						title: {
							display: true,
							text: 'Gender Distribution',
							font: {
								size: 14,
								weight: 'bold'
							}
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const label = context.label || '';
									const value = context.parsed;
									const absoluteValue = context.label === '‚ôÇ Male' ? genderData.male : genderData.female;
									return `${label}: ${value.toFixed(1)}% (${absoluteValue.toLocaleString()} people)`;
								}
							}
						},
						datalabels: {
							display: true,
							color: '#ffffff',
							font: {
								size: 14,
								weight: 'bold'
							},
							formatter: function(value, context) {
								return value.toFixed(1) + '%';
							}
						}
					},
					cutout: '60%', // Makes it a donut chart
					animation: {
						animateRotate: true,
						animateScale: true
					}
				}
			};
			
			// Create new chart
			window.genderChartInstance = new Chart(ctx, config);

			// Update gender summary
			const summaryText = `Gender distribution in the selected area is ${genderData.balance}, with ${genderData.femalePercent.toFixed(1)}% females and ${genderData.malePercent.toFixed(1)}% males.`;
			document.getElementById('genderSummary').textContent = summaryText;
		}

		// Function to extract and display weighted population data from nearby census sections
		function renderPopulationOverview(rows, municipalityRows = null) {
			console.log('=== RENDER POPULATION OVERVIEW DEBUG ===');
			console.log('Rendering population overview with SeccStats rows:', rows);
			console.log('=== END DEBUG ===');
			
			// Look for all POP_TOTAL values from SeccStats and sum them
			const popTotalData = rows.filter(r => r.indicator_code === 'POP_TOTAL' && r.value);
			
			if (popTotalData.length > 0) {
				console.log('Found POP_TOTAL data from SeccStats:', popTotalData.length, 'sections');
				console.log('POP_TOTAL values:', popTotalData.map(p => ({ area: p.secc_area_name, value: p.value })));
				
				// Sum all POP_TOTAL values
				const totalPop = popTotalData.reduce((sum, item) => sum + parseInt(item.value), 0);
				console.log('Sum of all POP_TOTAL values:', totalPop);
				
				// Display the summed POP_TOTAL value
				document.getElementById('totalPopulation').textContent = totalPop.toLocaleString();
				document.getElementById('populationLabel').textContent = 'Total Population';
				document.getElementById('populationSource').textContent = `Source: SeccStats (${popTotalData[0].year || 'N/A'}) - ${popTotalData.length} sections`;
				document.getElementById('populationArea').textContent = `${popTotalData.length} sections combined`;
				
				// Calculate population density using weighted section areas
				// Since sections may be partially covered, we use actual section areas from SeccStats
				// Formula: Weighted Density = Total Population / Total Area of Sections
				if (popTotalData.length > 0 && totalPop > 0) {
					// Find section areas from SeccStats data
					// Look for AREA_KM2 indicator for each section
					let totalArea = 0;
					let sectionsWithArea = 0;
					
					// Get unique section names from popTotalData
					const sectionNames = [...new Set(popTotalData.map(s => s.secc_area_name))];
					
					// Find area for each section
					sectionNames.forEach(sectionName => {
						// Find AREA_KM2 for this section
						const areaRow = rows.find(r => 
							r.indicator_code === 'AREA_KM2' && 
							r.secc_area_name === sectionName &&
							r.value
						);
						
						if (areaRow && areaRow.value) {
							const sectionArea = parseFloat(areaRow.value);
						if (sectionArea > 0) {
								totalArea += sectionArea;
								sectionsWithArea++;
								console.log(`[Demographics] Found area for section ${sectionName}: ${sectionArea} km¬≤`);
							}
						}
					});
					
					if (totalArea > 0) {
						// Calculate density: people per square kilometer using actual section areas
						const density = totalPop / totalArea;
						
						console.log('[Demographics] Density calculation (weighted by sections):');
						console.log('[Demographics] - Total Population (SeccStats):', totalPop);
						console.log('[Demographics] - Number of sections:', popTotalData.length);
						console.log('[Demographics] - Sections with area data:', sectionsWithArea);
						console.log('[Demographics] - Total Area (sum of section areas):', totalArea.toFixed(2), 'km¬≤');
						console.log('[Demographics] - Density:', density.toFixed(2), 'people/km¬≤');
						
						document.getElementById('densityValue').textContent = density.toLocaleString('en-US', {
						minimumFractionDigits: 1,
						maximumFractionDigits: 1
					}) + ' people/km¬≤';
				} else {
						// Fallback to radius-based calculation if no section areas available
						if (searchRadiusKm && searchRadiusKm > 0) {
							const searchArea = Math.PI * Math.pow(searchRadiusKm, 2);
							const density = totalPop / searchArea;
							
							console.log('[Demographics] Density calculation (fallback to radius):');
							console.log('[Demographics] - Total Population:', totalPop);
							console.log('[Demographics] - Search Radius:', searchRadiusKm, 'km');
							console.log('[Demographics] - Search Area (circle):', searchArea.toFixed(2), 'km¬≤');
							console.log('[Demographics] - Density:', density.toFixed(2), 'people/km¬≤');
							
							document.getElementById('densityValue').textContent = density.toLocaleString('en-US', {
								minimumFractionDigits: 1,
								maximumFractionDigits: 1
							}) + ' people/km¬≤';
						} else {
							console.warn('[Demographics] ‚ö†Ô∏è Cannot calculate density - no section areas or radius available');
							document.getElementById('densityValue').textContent = 'N/A';
						}
					}
				} else {
					console.warn('[Demographics] ‚ö†Ô∏è Cannot calculate density - no population data');
					document.getElementById('densityValue').textContent = 'N/A';
				}
				
				// Calculate percentage of municipality if available
				// We have: section population (totalPop) and need municipality population from Munistats
				if (municipalityRows && municipalityRows.length > 0) {
					console.log('[Demographics] Looking for POP_TOTAL in municipality data...');
					console.log('[Demographics] Municipality rows count:', municipalityRows.length);
					console.log('[Demographics] Section Population (SeccStats):', totalPop);
					
					// Try to find POP_TOTAL - first without strict filter
					let municipalityPop = municipalityRows.find(r => r.indicator_code === 'POP_TOTAL');
					
					// If not found, try with municipio_area_type_name filter
					if (!municipalityPop) {
						municipalityPop = municipalityRows.find(r => 
						r.indicator_code === 'POP_TOTAL' && 
						r.municipio_area_type_name === 'Municipio'
					);
					}
					
					// If still not found, try without any filter (just indicator_code)
					if (!municipalityPop) {
						console.log('[Demographics] Trying to find any POP_TOTAL...');
						const allPopTotal = municipalityRows.filter(r => r.indicator_code === 'POP_TOTAL');
						console.log('[Demographics] Found POP_TOTAL rows:', allPopTotal.length);
						if (allPopTotal.length > 0) {
							municipalityPop = allPopTotal[0]; // Use first one
						}
					}
					
					if (municipalityPop && municipalityPop.value) {
						const municipalityTotal = parseInt(municipalityPop.value);
						const percentage = (totalPop / municipalityTotal) * 100;
						
						console.log('[Demographics] ‚úÖ Percentage calculation:');
						console.log('[Demographics] - Section Population (SeccStats):', totalPop);
						console.log('[Demographics] - Municipality Population (Munistats):', municipalityTotal);
						console.log('[Demographics] - Percentage:', percentage.toFixed(1) + '%');
						
						document.getElementById('percentageValue').textContent = percentage.toFixed(1) + '%';
					} else {
						console.warn('[Demographics] ‚ö†Ô∏è POP_TOTAL not found in municipality data');
						console.warn('[Demographics] Available indicator codes:', [...new Set(municipalityRows.map(r => r.indicator_code))].slice(0, 15));
						document.getElementById('percentageValue').textContent = 'N/A';
					}
				} else {
					console.warn('[Demographics] ‚ö†Ô∏è No municipality data available for percentage calculation');
					document.getElementById('percentageValue').textContent = 'N/A';
				}
				
				console.log(`Population overview updated with summed POP_TOTAL: ${totalPop} residents from ${popTotalData.length} sections`);
				return;
			}
			
			// Fallback to original logic if POP_TOTAL not found
			console.log('POP_TOTAL not found in SeccStats, using fallback logic');
			renderSingleSectionPopulation(rows, municipalityRows);
		}
		
		// Fallback function for single section population (original logic)
		function renderSingleSectionPopulation(rows, municipalityRows = null) {
			console.log('[Demographics] Rendering single section population overview');
			
			// Look for population indicators in section-level data - prioritize POP_TOTAL from SeccStats
			const populationIndicators = [
				'POP_TOTAL', // Prioritize POP_TOTAL from SeccStats
				'EDU15P_TOTAL',
				'POPULATION_TOTAL',
				'TOTAL_POPULATION'
			];
			
			// Find section-level population data (not municipality level)
			let populationData = null;
			let areaData = null;
			let municipalityPopulationData = null;
			
			// First, try to find all POP_TOTAL values from SeccStats and sum them
			const popTotalData = rows.filter(r => 
				r.indicator_code === 'POP_TOTAL' && 
				r.secc_area_name && // Must have section area name
				r.value
			);
			
			if (popTotalData.length > 0) {
				console.log('Found POP_TOTAL data from SeccStats:', popTotalData.length, 'sections');
				console.log('POP_TOTAL values:', popTotalData.map(p => ({ area: p.secc_area_name, value: p.value })));
				
				// Sum all POP_TOTAL values
				const totalPop = popTotalData.reduce((sum, item) => sum + parseInt(item.value), 0);
				console.log('Sum of all POP_TOTAL values:', totalPop);
				
				// Use the first item for metadata (year, source, etc.)
				const firstItem = popTotalData[0];
				
				// Update the population display
				document.getElementById('totalPopulation').textContent = totalPop.toLocaleString();
				document.getElementById('populationLabel').textContent = 'Total Population';
				document.getElementById('populationSource').textContent = `Source: SeccStats (${firstItem.year || 'N/A'}) - ${popTotalData.length} sections`;
				document.getElementById('populationArea').textContent = `${popTotalData.length} sections combined`;
				
				// Calculate population density using weighted section areas
				// Since sections may be partially covered, we use actual section areas from SeccStats
				if (popTotalData.length > 0 && totalPop > 0) {
					// Find section areas from SeccStats data
					let totalArea = 0;
					let sectionsWithArea = 0;
					
					// Get unique section names from popTotalData
					const sectionNames = [...new Set(popTotalData.map(s => s.secc_area_name))];
					
					// Find area for each section
					sectionNames.forEach(sectionName => {
						// Find AREA_KM2 for this section
						const areaRow = rows.find(r => 
							r.indicator_code === 'AREA_KM2' && 
							r.secc_area_name === sectionName &&
							r.value
						);
						
						if (areaRow && areaRow.value) {
							const sectionArea = parseFloat(areaRow.value);
						if (sectionArea > 0) {
								totalArea += sectionArea;
								sectionsWithArea++;
								console.log(`[Demographics] Found area for section ${sectionName}: ${sectionArea} km¬≤`);
							}
						}
					});
					
					if (totalArea > 0) {
						// Calculate density: people per square kilometer using actual section areas
						const density = totalPop / totalArea;
						
						console.log('[Demographics] Density calculation (single section path, weighted by sections):');
						console.log('[Demographics] - Total Population (SeccStats):', totalPop);
						console.log('[Demographics] - Number of sections:', popTotalData.length);
						console.log('[Demographics] - Sections with area data:', sectionsWithArea);
						console.log('[Demographics] - Total Area (sum of section areas):', totalArea.toFixed(2), 'km¬≤');
						console.log('[Demographics] - Density:', density.toFixed(2), 'people/km¬≤');
						
						document.getElementById('densityValue').textContent = density.toLocaleString('en-US', {
						minimumFractionDigits: 1,
						maximumFractionDigits: 1
					}) + ' people/km¬≤';
				} else {
						// Fallback to radius-based calculation if no section areas available
						if (searchRadiusKm && searchRadiusKm > 0) {
							const searchArea = Math.PI * Math.pow(searchRadiusKm, 2);
							const density = totalPop / searchArea;
							
							console.log('[Demographics] Density calculation (single section, fallback to radius):');
							console.log('[Demographics] - Total Population:', totalPop);
							console.log('[Demographics] - Search Radius:', searchRadiusKm, 'km');
							console.log('[Demographics] - Search Area (circle):', searchArea.toFixed(2), 'km¬≤');
							console.log('[Demographics] - Density:', density.toFixed(2), 'people/km¬≤');
							
							document.getElementById('densityValue').textContent = density.toLocaleString('en-US', {
								minimumFractionDigits: 1,
								maximumFractionDigits: 1
							}) + ' people/km¬≤';
						} else {
							console.warn('[Demographics] ‚ö†Ô∏è Cannot calculate density - no section areas or radius');
							document.getElementById('densityValue').textContent = 'N/A';
						}
					}
				} else {
					console.warn('[Demographics] ‚ö†Ô∏è Cannot calculate density - no population data');
					document.getElementById('densityValue').textContent = 'N/A';
				}
				
				// Calculate percentage of municipality if available
				if (municipalityRows && municipalityRows.length > 0) {
					console.log('[Demographics] Single section path - Looking for POP_TOTAL...');
					
					let municipalityPop = municipalityRows.find(r => r.indicator_code === 'POP_TOTAL');
					
					if (!municipalityPop) {
						municipalityPop = municipalityRows.find(r => 
						r.indicator_code === 'POP_TOTAL' && 
						r.municipio_area_type_name === 'Municipio'
					);
					}
					
					if (municipalityPop && municipalityPop.value) {
						const municipalityTotal = parseInt(municipalityPop.value);
						const percentage = (totalPop / municipalityTotal) * 100;
						
						console.log('[Demographics] ‚úÖ Percentage (single section):', percentage.toFixed(1) + '%');
						console.log('[Demographics] - Section Pop:', totalPop, 'Municipality Pop:', municipalityTotal);
						document.getElementById('percentageValue').textContent = percentage.toFixed(1) + '%';
					} else {
						console.warn('[Demographics] ‚ö†Ô∏è POP_TOTAL not found in single section path');
						console.warn('[Demographics] Available codes:', [...new Set(municipalityRows.map(r => r.indicator_code))].slice(0, 10));
						document.getElementById('percentageValue').textContent = 'N/A';
					}
				} else {
					console.warn('[Demographics] ‚ö†Ô∏è No municipality data in single section path');
					document.getElementById('percentageValue').textContent = 'N/A';
				}
				
				console.log(`Single section population overview updated with summed POP_TOTAL: ${totalPop} residents from ${popTotalData.length} sections`);
				return;
			}
			
			// Fallback to other indicators if POP_TOTAL not found
			console.log('POP_TOTAL not found in SeccStats, trying fallback indicators');
			for (const indicator of populationIndicators) {
				populationData = rows.find(r => 
					(r.indicator_code === indicator || 
					 (r.indicator_name && r.indicator_name.toLowerCase().includes(indicator.toLowerCase()))) &&
					r.secc_area_name && // Must have section area name
					!r.municipio_area_name // Should not be municipality level
				);
				if (populationData) break;
			}
			
			// If not found, look for any population-related indicator at section level
			if (!populationData) {
				populationData = rows.find(r => 
					r.indicator_name && 
					r.indicator_name.toLowerCase().includes('population') &&
					r.secc_area_name && // Must have section area name
					!r.municipio_area_name // Should not be municipality level
				);
			}
			
			// If still not found, try any EDU15P_TOTAL regardless of area type
			if (!populationData) {
				populationData = rows.find(r => r.indicator_code === 'EDU15P_TOTAL');
			}
			
			// Look for municipality-level population data for percentage calculation
			if (populationData && municipalityRows) {
				// Try to find municipality total population from municipality data
				for (const indicator of populationIndicators) {
					municipalityPopulationData = municipalityRows.find(r => 
						r.indicator_code === indicator || 
						(r.indicator_name && r.indicator_name.toLowerCase().includes(indicator.toLowerCase()))
					);
					if (municipalityPopulationData) break;
				}
				
				// If not found, look for any municipality-level population data
				if (!municipalityPopulationData) {
					municipalityPopulationData = municipalityRows.find(r => 
						r.indicator_name && 
						r.indicator_name.toLowerCase().includes('population')
					);
				}
			}
			
			// Look for area data if population found
			if (populationData) {
				areaData = rows.find(r => 
					r.indicator_code === 'AREA_KM2' || 
					r.indicator_name && r.indicator_name.toLowerCase().includes('area')
				);
			}
			
			if (populationData && populationData.value) {
				const totalPop = parseInt(populationData.value);
				const year = populationData.year || 'N/A';
				const source = populationData.source || 'Unknown source';
				const areaName = populationData.secc_area_name || 'Selected Section';
				
				// Extract section number from area name (e.g., "Secci√≥n 001")
				const sectionMatch = areaName.match(/Secci√≥n (\d+)/);
				const sectionNumber = sectionMatch ? sectionMatch[1] : 'N/A';
				
				// Update the population display
				document.getElementById('totalPopulation').textContent = totalPop.toLocaleString();
				document.getElementById('populationLabel').textContent = `Population (Secci√≥n ${sectionNumber})`;
				document.getElementById('populationSource').textContent = `As of ${year} (${source})`;
				document.getElementById('populationArea').textContent = areaName;
				
				// Calculate and display density using weighted section areas
				// Try to use actual section areas first, then fallback to radius or single section area
				if (totalPop > 0) {
					let density = 0;
					let calculationMethod = '';
					
					// First, try to find section areas from the rows data
					const sectionAreaRows = rows.filter(r => 
						r.indicator_code === 'AREA_KM2' && 
						r.secc_area_name && 
						r.value
					);
					
					if (sectionAreaRows.length > 0) {
						// Sum all section areas
						const totalArea = sectionAreaRows.reduce((sum, r) => sum + parseFloat(r.value || 0), 0);
						
						if (totalArea > 0) {
							density = totalPop / totalArea;
							calculationMethod = `weighted by ${sectionAreaRows.length} sections (area data)`;
							
							console.log('[Demographics] Density calculation (weighted by section areas):');
							console.log('[Demographics] - Total Population:', totalPop);
							console.log('[Demographics] - Number of sections:', sectionAreaRows.length);
							console.log('[Demographics] - Total Area (sum of section areas):', totalArea.toFixed(2), 'km¬≤');
							console.log('[Demographics] - Density:', density.toFixed(2), 'people/km¬≤');
						}
					}
					
					// If no section areas found, try single section area
					if (density === 0 && areaData && areaData.value) {
					const areaKm2 = parseFloat(areaData.value);
						if (areaKm2 > 0) {
							density = totalPop / areaKm2;
							calculationMethod = 'using single section area';
							
							console.log('[Demographics] Density calculation (using single section area):');
							console.log('[Demographics] - Total Population:', totalPop);
							console.log('[Demographics] - Section Area:', areaKm2, 'km¬≤');
							console.log('[Demographics] - Density:', density.toFixed(2), 'people/km¬≤');
						}
					}
					
					// Last fallback: use radius-based calculation
					if (density === 0 && searchRadiusKm && searchRadiusKm > 0) {
						const searchArea = Math.PI * Math.pow(searchRadiusKm, 2);
						density = totalPop / searchArea;
						calculationMethod = 'using radius (fallback)';
						
						console.log('[Demographics] Density calculation (fallback to radius):');
						console.log('[Demographics] - Total Population:', totalPop);
						console.log('[Demographics] - Search Radius:', searchRadiusKm, 'km');
						console.log('[Demographics] - Search Area (circle):', searchArea.toFixed(2), 'km¬≤');
						console.log('[Demographics] - Density:', density.toFixed(2), 'people/km¬≤');
					}
					
					if (density > 0) {
					document.getElementById('densityValue').textContent = density.toLocaleString('en-US', {
						minimumFractionDigits: 1,
						maximumFractionDigits: 1
					}) + ' people/km¬≤';
						console.log('[Demographics] ‚úÖ Density calculated:', calculationMethod);
				} else {
						console.warn('[Demographics] ‚ö†Ô∏è Cannot calculate density - no area data available');
						document.getElementById('densityValue').textContent = 'N/A';
					}
				} else {
					console.warn('[Demographics] ‚ö†Ô∏è Cannot calculate density - no population data');
					document.getElementById('densityValue').textContent = 'N/A';
				}
				
				// Calculate and display percentage of municipality population
				if (municipalityPopulationData && municipalityPopulationData.value) {
					const municipalityPop = parseInt(municipalityPopulationData.value);
					const percentage = (totalPop / municipalityPop) * 100;
					
					console.log('[Demographics] ‚úÖ Percentage calculation (fallback):');
					console.log('[Demographics] - Section Population:', totalPop);
					console.log('[Demographics] - Municipality Population:', municipalityPop);
					console.log('[Demographics] - Percentage:', percentage.toFixed(1) + '%');
					
					// Display percentage as separate metric
					document.getElementById('percentageValue').textContent = percentage.toFixed(1) + '%';
				} else {
					console.warn('[Demographics] ‚ö†Ô∏è No municipality population data found for percentage');
					// Show "N/A" if no municipality data
					document.getElementById('percentageValue').textContent = 'N/A';
				}
				
				console.log(`Single section population overview updated: ${totalPop} residents in ${areaName}`);
			} else {
				// Show fallback message
				document.getElementById('totalPopulation').textContent = '-';
				document.getElementById('populationLabel').textContent = 'Total Population';
				document.getElementById('densityValue').textContent = '-';
				document.getElementById('percentageValue').textContent = '-';
				document.getElementById('populationSource').textContent = 'Population data unavailable for this section.';
				document.getElementById('populationArea').textContent = '';
				
				console.log('No section-level population data found');
			}
		}

		// Function to process gender data from SeccStats
		// Step 1: Filter by indicator_code = POP_TOTAL
		// Step 2: Filter by subgroup = 'female' or 'male'
		// Step 3: Sum all values
		function processGenderData(rows) {
			console.log('[Gender] Processing gender data from SeccStats rows...');
			console.log('[Gender] Total rows:', rows.length);
			
			// First, get total population from SeccStats (POP_TOTAL) for validation
			const popTotalData = rows.filter(r => r.indicator_code === 'POP_TOTAL' && r.value);
			const totalPopulationFromSeccStats = popTotalData.reduce((sum, item) => sum + parseInt(item.value), 0);
			console.log('[Gender] Total population from SeccStats (POP_TOTAL):', totalPopulationFromSeccStats);
			
			// Filter: indicator_code = 'POP_TOTAL' AND subgroup = 'female'
			// Then sum all values
			const allFemaleData = rows.filter(r => {
				const isPopTotal = r.indicator_code === 'POP_TOTAL';
				const isFemale = r.subgroup && r.subgroup.toLowerCase() === 'female';
				const hasValue = r.value && parseInt(r.value) > 0;
				return isPopTotal && isFemale && hasValue;
			});
			
			// Filter: indicator_code = 'POP_TOTAL' AND subgroup = 'male'
			// Then sum all values
			const allMaleData = rows.filter(r => {
				const isPopTotal = r.indicator_code === 'POP_TOTAL';
				const isMale = r.subgroup && r.subgroup.toLowerCase() === 'male';
				const hasValue = r.value && parseInt(r.value) > 0;
				return isPopTotal && isMale && hasValue;
			});

			console.log('[Gender] Male data found:', allMaleData.length, 'sections');
			console.log('[Gender] Female data found:', allFemaleData.length, 'sections');
			
			if (allMaleData.length > 0) {
				console.log('[Gender] Sample male data:', allMaleData.slice(0, 3).map(r => ({
					indicator: r.indicator_code,
					subgroup: r.subgroup,
					section: r.secc_area_name,
					value: r.value
				})));
			}
			
			if (allFemaleData.length > 0) {
				console.log('[Gender] Sample female data:', allFemaleData.slice(0, 3).map(r => ({
					indicator: r.indicator_code,
					subgroup: r.subgroup,
					section: r.secc_area_name,
					value: r.value
				})));
			}

			if (allMaleData.length === 0 || allFemaleData.length === 0) {
				console.warn('[Gender] ‚ö†Ô∏è No gender data found in SeccStats');
				console.warn('[Gender] Available subgroups:', [...new Set(rows.map(r => r.subgroup).filter(Boolean))]);
				console.warn('[Gender] Sample rows with POP_TOTAL:', rows.filter(r => r.indicator_code === 'POP_TOTAL').slice(0, 5).map(r => ({
					indicator: r.indicator_code,
					subgroup: r.subgroup,
					value: r.value
				})));
				console.warn('[Gender] All unique indicator codes:', [...new Set(rows.map(r => r.indicator_code).filter(Boolean))].slice(0, 20));
				return { hasData: false };
			}

			// Sum all male and female values from SeccStats
			const totalMaleValue = allMaleData.reduce((sum, item) => sum + parseInt(item.value || 0), 0);
			const totalFemaleValue = allFemaleData.reduce((sum, item) => sum + parseInt(item.value || 0), 0);
			const totalGender = totalMaleValue + totalFemaleValue;

			console.log('[Gender] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
			console.log('[Gender] Gender Distribution from SeccStats:');
			console.log('[Gender] - Male:', totalMaleValue, `(${allMaleData.length} sections)`);
			console.log('[Gender] - Female:', totalFemaleValue, `(${allFemaleData.length} sections)`);
			console.log('[Gender] - Total (Male + Female):', totalGender);
			console.log('[Gender] - Total Population (POP_TOTAL):', totalPopulationFromSeccStats);
			
			// Validate: gender total should match or be close to total population
			const difference = Math.abs(totalGender - totalPopulationFromSeccStats);
			const differencePercent = totalPopulationFromSeccStats > 0 ? (difference / totalPopulationFromSeccStats) * 100 : 0;
			console.log('[Gender] - Difference:', difference, `(${differencePercent.toFixed(1)}%)`);
			
			if (differencePercent > 5) {
				console.warn('[Gender] ‚ö†Ô∏è Gender total differs from POP_TOTAL by more than 5%');
			}
			console.log('[Gender] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

			// Calculate percentages based on gender total
			const malePercent = totalGender > 0 ? (totalMaleValue / totalGender) * 100 : 0;
			const femalePercent = totalGender > 0 ? (totalFemaleValue / totalGender) * 100 : 0;

			console.log('[Gender] Percentages:');
			console.log('[Gender] - Male:', malePercent.toFixed(1) + '%');
			console.log('[Gender] - Female:', femalePercent.toFixed(1) + '%');

			// Determine balance
			let balance = 'balanced';
			if (Math.abs(malePercent - femalePercent) > 10) {
				balance = malePercent > femalePercent ? 'male-dominated' : 'female-dominated';
			}

			return {
				hasData: true,
				male: totalMaleValue,
				female: totalFemaleValue,
				total: totalGender,
				totalPopulation: totalPopulationFromSeccStats, // Include for reference
				malePercent: malePercent,
				femalePercent: femalePercent,
				balance: balance
			};
		}

		// Function to generate colors dynamically for charts
		function generateColors(count) {
			const baseColors = [
				'#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
				'#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1',
				'#14b8a6', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4',
				'#84cc16', '#f97316', '#ec4899', '#6366f1', '#14b8a6'
			];
			
			const colors = [];
			for (let i = 0; i < count; i++) {
				colors.push(baseColors[i % baseColors.length]);
			}
			return colors;
		}

		// Function to render ethnicity and nationality chart
		function renderEthnicityChart(rows) {
			const container = document.getElementById('ethnicityChart');
			if (!container) {
				console.log('Ethnicity chart container not found');
				return;
			}

			// Clear existing content
			container.innerHTML = '';

			// Process ethnicity data
			const ethnicityData = processEthnicityData(rows);
			
			if (ethnicityData.length === 0) {
				console.log('No ethnicity data available');
				container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No ethnicity data available</div>';
				return;
			}

			// Create treemap data structure
			const total = ethnicityData.reduce((sum, item) => sum + item.value, 0);
			const treemapData = {
				name: "Population by Origin",
				children: ethnicityData.map(item => ({
					name: item.label,
					value: item.value,
					percentage: ((item.value / total) * 100).toFixed(1)
				}))
			};

			// Set up dimensions
			const width = container.offsetWidth;
			const height = container.offsetHeight;

			// Create SVG
			const svg = d3.select(container)
				.append("svg")
				.attr("width", width)
				.attr("height", height);

			// Create treemap layout
			const treemap = d3.treemap()
				.size([width, height])
				.padding(2);

			// Create root hierarchy
			const root = d3.hierarchy(treemapData)
				.sum(d => d.value)
				.sort((a, b) => b.value - a.value);

			// Generate treemap
			treemap(root);

			// Defined color scheme
			const colorScheme = {
				'Spanish': '#2b945f',        // Spanish Green - Native / closest
				'Espa√±a': '#2b945f',       // Spanish Green - Native / closest (Spanish name)
				'Spain': '#2b945f',        // Spanish Green - Native / closest
				'Spanish Born': '#2b945f', // Spanish Green - Native / closest
				'Europe (Non-Spanish)': '#4A90E2',       // Blue - Close proximity
				'Europe': '#4A90E2',       // Blue - Close proximity
				'Americas': '#F28E2B', // Orange - Medium proximity
				'Latin America': '#F28E2B', // Orange - Medium proximity
				'North America': '#F4A261', // Soft Orange - Culturally connected, geographically distant
				'Asia': '#E15759',         // Red - Culturally distinct, smaller presence
				'Africa': '#B71C1C',       // Deep Red - Least proximity
				'Other': '#8B5CF6',       // Purple - Unspecified
				'Oceania': '#F6AE2D',      // Gold Orange - Distant but moderate connection
				'Unspecified': '#D3D3D3'   // Light Grey
			};

			// Debug: Log the actual labels
			console.log('Ethnicity labels:', ethnicityData.map(d => d.label));
			
			// Color scale with defined colors
			const color = d3.scaleOrdinal()
				.domain(ethnicityData.map(d => d.label))
				.range(ethnicityData.map(d => {
					// Try exact match first
					if (colorScheme[d.label]) {
						return colorScheme[d.label];
					}
					// Try case-insensitive match for Spanish categories
					const lowerLabel = d.label.toLowerCase();
					if (lowerLabel.includes('spain') || lowerLabel.includes('espa√±a') || 
						lowerLabel.includes('spanish') || lowerLabel.includes('espa√±ol') ||
						lowerLabel === 'spain' || lowerLabel === 'espa√±a' ||
						lowerLabel.startsWith('spain') || lowerLabel.startsWith('espa√±a') ||
						lowerLabel.startsWith('spanish') || lowerLabel.startsWith('espa√±ol')) {
						console.log('Spanish category detected with label:', d.label, '-> Spanish Green color #2b945f');
						return '#2b945f'; // Spanish Green color
					}
					if (lowerLabel.includes('europe')) {
						return '#95D5B2'; // Europe color
					}
					if (lowerLabel.includes('latin america')) {
						return '#FFD166'; // Latin America color
					}
					if (lowerLabel.includes('north america')) {
						return '#F4A261'; // North America color
					}
					if (lowerLabel.includes('oceania')) {
						return '#F6AE2D'; // Oceania color
					}
					if (lowerLabel.includes('asia')) {
						return '#E63946'; // Asia color
					}
					if (lowerLabel.includes('africa')) {
						return '#B71C1C'; // Africa color
					}
					// Default to gray for unspecified
					return '#E0E0E0';
				}));

			// Create cells
			const cells = svg.selectAll("g")
				.data(root.leaves())
				.enter()
				.append("g")
				.attr("transform", d => `translate(${d.x0},${d.y0})`);

			// Add rectangles
			cells.append("rect")
				.attr("width", d => d.x1 - d.x0)
				.attr("height", d => d.y1 - d.y0)
				.attr("fill", d => color(d.data.name))
				.attr("stroke", "#ffffff")
				.attr("stroke-width", 2)
				.style("cursor", "pointer")
				.on("mouseover", function(event, d) {
					// Highlight on hover
					d3.select(this)
						.attr("stroke", "#000000")
						.attr("stroke-width", 3);
				})
				.on("mouseout", function(event, d) {
					// Remove highlight
					d3.select(this)
						.attr("stroke", "#ffffff")
						.attr("stroke-width", 2);
				});

			// Add text labels with two separate lines
			cells.each(function(d) {
				const cell = d3.select(this);
					const width = d.x1 - d.x0;
					const height = d.y1 - d.y0;
				const centerX = width / 2;
				const centerY = height / 2;
					
				// Calculate font size based on box size
				let fontSize;
					if (width > 100 && height > 50) {
					fontSize = Math.min(width / 12, height / 6, 18); // Very large boxes
					} else if (width > 70 && height > 35) {
					fontSize = Math.min(width / 10, height / 5, 16); // Large boxes
					} else if (width > 50 && height > 25) {
					fontSize = Math.min(width / 8, height / 4, 14); // Medium boxes
					} else if (width > 35 && height > 18) {
					fontSize = Math.min(width / 6, height / 3, 12); // Small boxes
					} else if (width > 25 && height > 12) {
					fontSize = Math.min(width / 5, height / 2.5, 10); // Very small boxes
					} else {
					fontSize = Math.min(width / 4, height / 2, 8); // Tiny boxes
				}
				
				// Only add text if box is large enough
				if (width > 25 && height > 12) {
					// First line: Category name
					if (width > 35 && height > 18) {
						cell.append("text")
							.attr("x", centerX)
							.attr("y", centerY - fontSize * 0.5)
							.attr("text-anchor", "middle")
							.attr("dominant-baseline", "middle")
							.attr("fill", "#ffffff")
							.attr("font-size", fontSize)
				.attr("font-weight", "bold")
				.attr("pointer-events", "none")
							.text(d.data.name);
					}
					
					// Second line: Percentage and population
					if (width > 50 && height > 25) {
						// Show percentage and population
						cell.append("text")
							.attr("x", centerX)
							.attr("y", centerY + fontSize * 0.5)
							.attr("text-anchor", "middle")
							.attr("dominant-baseline", "middle")
							.attr("fill", "#ffffff")
							.attr("font-size", fontSize * 0.9)
							.attr("font-weight", "bold")
							.attr("pointer-events", "none")
							.text(`${d.data.percentage}% (${d.data.value.toLocaleString()})`);
					} else if (width > 35 && height > 18) {
						// Show only percentage
						cell.append("text")
							.attr("x", centerX)
							.attr("y", centerY + fontSize * 0.5)
							.attr("text-anchor", "middle")
							.attr("dominant-baseline", "middle")
							.attr("fill", "#ffffff")
							.attr("font-size", fontSize * 0.9)
							.attr("font-weight", "bold")
							.attr("pointer-events", "none")
							.text(`${d.data.percentage}%`);
						} else {
						// Very small box: show only percentage
						cell.append("text")
							.attr("x", centerX)
							.attr("y", centerY)
							.attr("text-anchor", "middle")
							.attr("dominant-baseline", "middle")
							.attr("fill", "#ffffff")
							.attr("font-size", fontSize)
							.attr("font-weight", "bold")
							.attr("pointer-events", "none")
							.text(`${d.data.percentage}%`);
					}
				}
				});

			// Store reference for cleanup
			window.ethnicityChartInstance = { destroy: () => container.innerHTML = '' };
		}

		// Helper function to get age range for display
		function getAgeRange(cluster) {
			const ageRanges = {
				'Children': '(0-14)',
				'Youth': '(15-24)',
				'Young Adults': '(25-39)',
				'Middle Age': '(40-64)',
				'Seniors': '(65+)'
			};
			return ageRanges[cluster] || '';
		}

		// Function to process age distribution data with clustered groups
		function processAgeData(rows) {
			console.log('[Age Distribution] Processing age data from rows:', rows.length);
			
			// Age indicators to filter by indicator_name (exact names from SeccStats)
			const ageIndicatorNames = [
				'Population aged 0 to 14 years',
				'Population aged 15 to 24 years',
				'Population aged 25 to 39 years',
				'Population aged 40 to 64 years',
				'Population aged 65 years and over'
			];
			
			// Map indicator names to cluster names
			const indicatorToCluster = {
				'Population aged 0 to 14 years': 'Children',
				'Population aged 15 to 24 years': 'Youth',
				'Population aged 25 to 39 years': 'Young Adults',
				'Population aged 40 to 64 years': 'Middle Age',
				'Population aged 65 years and over': 'Seniors'
			};
			
			// Initialize cluster data
			const clusterData = {};
			Object.values(indicatorToCluster).forEach(cluster => {
				clusterData[cluster] = { total: 0, sectionCount: 0 };
			});
			
			// Filter and sum age data from SeccStats for each indicator
			ageIndicatorNames.forEach(indicatorName => {
				// Filter rows by indicator_name (case-insensitive match)
				const matchingRows = rows.filter(r => {
					const rowIndicatorName = r.indicator_name ? r.indicator_name.trim() : '';
					return rowIndicatorName.toLowerCase() === indicatorName.toLowerCase() && 
						   r.value && 
						   (r.secc_area_name || r.area_name);
				});
				
				// Sum all values for this indicator across all sections
				const total = matchingRows.reduce((sum, row) => {
					const value = parseInt(row.value) || 0;
					return sum + value;
				}, 0);
				
				// Get cluster name for this indicator
				const clusterName = indicatorToCluster[indicatorName];
				if (clusterName) {
					clusterData[clusterName].total += total;
					clusterData[clusterName].sectionCount = new Set(matchingRows.map(r => r.secc_area_name || r.area_name)).size;
					
					console.log(`[Age Distribution] ${indicatorName} (${clusterName}):`, {
						total: total.toLocaleString(),
						sections: clusterData[clusterName].sectionCount,
						rows: matchingRows.length
					});
				}
			});
			
			// Calculate total population for percentage calculation
			const totalPopulation = Object.values(clusterData).reduce((sum, data) => sum + data.total, 0);
			
			console.log(`[Age Distribution] Total population: ${totalPopulation.toLocaleString()}`);
			
			// Convert to array format for chart with percentages
			const ageData = Object.entries(clusterData).map(([cluster, data]) => ({
				cluster,
				total: data.total,
				percentage: totalPopulation > 0 ? (data.total / totalPopulation) * 100 : 0,
				sectionCount: data.sectionCount
			}));
			
			console.log('[Age Distribution] Processed age cluster data:', ageData);
			return ageData;
		}

		// Function to render age distribution chart (always uses radius view)
		function renderAgeDistributionChartWithMode(allRows) {
			// Always use radius view: use all sections within the radius
				console.log('Rendering age distribution in RADIUS mode (all sections)');
					renderAgeDistributionChart(allRows);
		}

		// Function to render age distribution bar chart
		function renderAgeDistributionChart(rows) {
			const container = document.getElementById('ageDistributionChart');
			if (!container) {
				console.log('Age distribution chart container not found');
				return;
			}

			// Clear existing content
			container.innerHTML = '';

			// Process age data
			const ageData = processAgeData(rows);
			
			if (ageData.length === 0) {
				console.log('No age data available');
				container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No age data available</div>';
				return;
			}

			// Set up dimensions
			const width = container.offsetWidth;
			const height = container.offsetHeight;
			const margin = { top: 20, right: 40, bottom: 40, left: 100 };
			const chartWidth = width - margin.left - margin.right;
			const chartHeight = height - margin.top - margin.bottom;

			// Create SVG
			const svg = d3.select(container)
				.append("svg")
				.attr("width", width)
				.attr("height", height);

			// Create scales (using percentages)
			const maxPercentage = d3.max(ageData, d => d.percentage);
			const xScale = d3.scaleLinear()
				.domain([0, maxPercentage])
				.range([0, chartWidth]);

			const yScale = d3.scaleBand()
				.domain(ageData.map(d => d.cluster))
				.range([0, chartHeight])
				.padding(0.1);

			// Create chart group
			const chart = svg.append("g")
				.attr("transform", `translate(${margin.left},${margin.top})`);

			// Add axes
			const xAxis = d3.axisBottom(xScale)
				.tickFormat(d => d.toFixed(1) + '%')
				.ticks(5);

			// Create custom Y-axis with age ranges
			const yAxis = d3.axisLeft(yScale)
				.tickFormat(d => ''); // Remove default labels

			chart.append("g")
				.attr("class", "x-axis")
				.attr("transform", `translate(0,${chartHeight})`)
				.call(xAxis);

			chart.append("g")
				.attr("class", "y-axis")
				.call(yAxis);

			// Add custom labels with age ranges
			ageData.forEach((d, i) => {
				const y = yScale(d.cluster);
				const barHeight = yScale.bandwidth();
				
				// Main label (cluster name)
				chart.append("text")
					.attr("x", -10)
					.attr("y", y + barHeight / 2 - 5)
					.attr("text-anchor", "end")
					.attr("dominant-baseline", "middle")
					.attr("font-size", "12px")
					.attr("fill", "#333")
					.attr("font-weight", "500")
					.text(d.cluster);
				
				// Age range label (smaller font)
				chart.append("text")
					.attr("x", -10)
					.attr("y", y + barHeight / 2 + 8)
					.attr("text-anchor", "end")
					.attr("dominant-baseline", "middle")
					.attr("font-size", "10px")
					.attr("fill", "#666")
					.text(getAgeRange(d.cluster));
			});

			// Add axis labels
			chart.append("text")
				.attr("transform", "rotate(-90)")
				.attr("y", 0 - margin.left)
				.attr("x", 0 - (chartHeight / 2))
				.attr("dy", "1em")
				.style("text-anchor", "middle")
				.attr("font-size", "12px")
				.attr("fill", "#666")
				.text("Age Groups");

			chart.append("text")
				.attr("transform", `translate(${chartWidth / 2}, ${chartHeight + 35})`)
				.style("text-anchor", "middle")
				.attr("font-size", "12px")
				.attr("fill", "#666")
				.text("Percentage of Population");

			// Create tooltip
			const tooltip = d3.select("body").append("div")
				.attr("class", "chart-tooltip")
				.style("position", "absolute")
				.style("visibility", "hidden")
				.style("background", "rgba(0, 0, 0, 0.8)")
				.style("color", "white")
				.style("padding", "8px 12px")
				.style("border-radius", "4px")
				.style("font-size", "12px")
				.style("pointer-events", "none")
				.style("z-index", "1000");

			// Create bars
			ageData.forEach((d, i) => {
				const y = yScale(d.cluster);
				const barHeight = yScale.bandwidth() * 0.8;

				// Single bar for percentage
				if (d.percentage > 0) {
					chart.append("rect")
						.attr("x", 0)
						.attr("y", y + (barHeight - barHeight) / 2)
						.attr("width", xScale(d.percentage))
						.attr("height", barHeight)
						.attr("fill", "rgba(66, 135, 245, 0.8)")
						.attr("stroke", "#4287f5")
						.attr("stroke-width", 1)
						.style("cursor", "pointer")
						.on("mouseover", function(event) {
							d3.select(this).attr("fill", "rgba(66, 135, 245, 1)");
							
							// Show tooltip with actual numbers
							const sectionInfo = d.sectionCount ? ` (${d.sectionCount} sections)` : '';
							tooltip
								.style("visibility", "visible")
								.html(`
									<div><strong>${d.cluster} ${getAgeRange(d.cluster)}</strong></div>
									<div>Population: ${d.total.toLocaleString()}${sectionInfo}</div>
									<div>Percentage: ${d.percentage.toFixed(1)}%</div>
								`);
						})
						.on("mousemove", function(event) {
							// Position tooltip near mouse
							tooltip
								.style("left", (event.pageX + 10) + "px")
								.style("top", (event.pageY - 10) + "px");
						})
						.on("mouseout", function(event) {
							d3.select(this).attr("fill", "rgba(66, 135, 245, 0.8)");
							tooltip.style("visibility", "hidden");
						});
				}

				// Add percentage labels for larger bars
				if (d.percentage > maxPercentage * 0.05) {
					chart.append("text")
						.attr("x", xScale(d.percentage) + 5)
						.attr("y", y + barHeight / 2)
						.attr("dominant-baseline", "middle")
						.attr("font-size", "10px")
						.attr("fill", "#333")
						.attr("font-weight", "bold")
						.text(d.percentage.toFixed(1) + '%');
				}
			});

			// Store reference for cleanup
			window.ageDistributionChartInstance = { 
				destroy: () => {
					container.innerHTML = '';
					// Clean up tooltip
					d3.selectAll('.chart-tooltip').remove();
				}
			};
		}

		// Function to render migration patterns chart
		function renderMigrationChart(rows) {
			const ctx = document.getElementById('migrationChart');
			if (!ctx) {
				console.log('Migration chart canvas not found');
				return;
			}

			// Destroy existing chart if it exists
			if (window.migrationChartInstance) {
				window.migrationChartInstance.destroy();
			}

			// Process migration data
			const migrationData = processMigrationData(rows);
			
			if (migrationData.length === 0) {
				console.log('No migration data available');
				ctx.getContext('2d').fillText('No migration data available', ctx.width/2, ctx.height/2);
				return;
			}

			// Generate colors for migration chart
			const migrationColors = generateColors(migrationData.length);

			// Calculate total for percentage calculation
			const totalPopulation = migrationData.reduce((sum, item) => sum + item.value, 0);
			
			const migrationConfig = {
				type: "bar",
				data: {
					labels: migrationData.map(item => item.label),
					datasets: [{
						label: '',
						data: migrationData.map(item => ((item.value / totalPopulation) * 100)),
						backgroundColor: migrationColors,
						borderColor: '#ffffff',
						borderWidth: 1
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						y: {
							beginAtZero: true,
							ticks: {
								callback: function(value) {
									return value.toFixed(1) + '%';
								}
							}
						}
					},
					plugins: {
						legend: { display: false },
						title: { 
							display: true, 
							text: "Migration Patterns",
							font: { size: 14 }
						},
						datalabels: {
							display: true,
							color: '#ffffff',
							font: {
								size: 12,
								weight: 'bold'
							},
							formatter: function(value, context) {
								return value.toFixed(1) + '%';
							},
							anchor: 'center',
							align: 'center'
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const value = context.parsed.y;
									return `${value.toFixed(1)}%`;
								}
							}
						}
					}
				}
			};

			window.migrationChartInstance = new Chart(ctx, migrationConfig);
		}

		// Helper function to detect European countries
		function isEuropeanCountry(countryName, indicatorCode) {
			const europeanCountries = [
				// Western Europe
				'germany', 'france', 'italy', 'spain', 'portugal', 'netherlands', 'belgium', 'switzerland', 'austria', 'luxembourg',
				// British Isles
				'united kingdom', 'england', 'scotland', 'wales', 'northern ireland', 'ireland', 'britain', 'uk',
				// Nordic Countries
				'sweden', 'norway', 'denmark', 'finland', 'iceland',
				// Eastern Europe
				'poland', 'romania', 'bulgaria', 'hungary', 'czech republic', 'slovakia', 'slovenia', 'croatia', 'serbia', 'bosnia', 'montenegro', 'albania', 'macedonia',
				// Baltic States
				'estonia', 'latvia', 'lithuania',
				// Other European
				'greece', 'cyprus', 'malta', 'liechtenstein', 'monaco', 'san marino', 'vatican',
				// Former Soviet (European part)
				'russia', 'ukraine', 'belarus', 'moldova',
				// Additional European countries
				'andorra', 'liechtenstein', 'monaco', 'san marino', 'vatican city', 'kosovo', 'montenegro'
			];
			
			const countryLower = countryName.toLowerCase();
			return europeanCountries.some(country => countryLower.includes(country));
		}

		// Helper function to detect Oceania countries
		function isOceaniaCountry(countryName, indicatorCode) {
			const oceaniaCountries = [
				'australia', 'new zealand', 'fiji', 'papua new guinea', 'samoa', 'tonga', 'vanuatu', 'solomon islands',
				'palau', 'marshall islands', 'micronesia', 'kiribati', 'tuvalu', 'nauru', 'cook islands', 'niue'
			];
			
			const countryLower = countryName.toLowerCase();
			return oceaniaCountries.some(country => countryLower.includes(country));
		}

		// Function to process ethnicity data using nationality indicators
		function processEthnicityData(rows) {
			const ethnicityData = [];
			
			console.log('Processing ethnicity data from rows using nationality indicators:', rows);
			
			// Get total population using the same logic as the KPI display
			const popTotalData = rows.filter(r => r.indicator_code === 'POP_TOTAL' && r.value);
			const totalPopulation = popTotalData.reduce((sum, item) => sum + parseInt(item.value), 0);
			console.log('Total population (sum of all POP_TOTAL):', totalPopulation);
			console.log('POP_TOTAL data found:', popTotalData.length, 'sections');
			
			// Define foreign nationality indicators
			const foreignNationalityIndicators = {
				'Africa': 'POP_NAT_FOR_AF',
				'Americas': 'POP_NAT_FOR_AM', 
				'Asia': 'POP_NAT_FOR_AS',
				'Europe (Non-Spanish)': 'POP_NAT_FOR_EU_NO_ES',
				'Other': 'POP_NAT_FOR_OTHER'
			};
			
			// Calculate foreign nationalities by summing all matching rows
			let totalForeignNationalities = 0;
			const foreignNationalityData = {};
			
			Object.entries(foreignNationalityIndicators).forEach(([region, indicatorCode]) => {
				// Find ALL rows that match this indicator code and sum their values
				const matchingRows = rows.filter(r => r.indicator_code === indicatorCode);
				console.log(`Looking for ${indicatorCode} (${region}):`, matchingRows);
				
				// Sum all values from matching rows
				const totalValue = matchingRows.reduce((sum, row) => {
					return sum + (parseInt(row.value) || 0);
				}, 0);
				
				console.log(`Total value for ${region}:`, totalValue);
				
				if (totalValue > 0) {
					foreignNationalityData[region] = totalValue;
					totalForeignNationalities += totalValue;
					
					ethnicityData.push({
						label: region,
						value: totalValue,
						percentage: totalPopulation > 0 ? (totalValue / totalPopulation) * 100 : 0
					});
				}
			});
			
			console.log('Foreign nationality data:', foreignNationalityData);
			console.log('Total foreign nationalities:', totalForeignNationalities);
			
			// Calculate Spanish population: Total - All Foreign Nationalities
			if (totalPopulation > 0) {
				const spanishPopulation = totalPopulation - totalForeignNationalities;
				console.log('Calculated Spanish population:', spanishPopulation);
				console.log('Total population used:', totalPopulation);
				console.log('Total foreign nationalities:', totalForeignNationalities);
				
				if (spanishPopulation > 0) {
					ethnicityData.push({
						label: 'Spanish',
						value: spanishPopulation,
						percentage: (spanishPopulation / totalPopulation) * 100
					});
				}
			}

			// Sort by value (largest first) for better chart display
			ethnicityData.sort((a, b) => b.value - a.value);

			console.log('Processed ethnicity data:', ethnicityData);
			return ethnicityData;
		}

		// Function to process migration data
		function processMigrationData(rows) {
			const migrationData = [];
			
			console.log('Processing migration data from rows:', rows);
			
			// Look for migration pattern data
			const migrationPatterns = [
				{ code: 'POP_BIRTHRES_ES_SAME_MUNI', name: 'Same Municipality' },
				{ code: 'POP_BIRTHRES_ES_SAME_PROV_DIFF_MUNI', name: 'Same Province, Different Municipality' },
				{ code: 'POP_BIRTHRES_ES_DIFF_PROV_SAME_CCAA', name: 'Different Province, Same Region' },
				{ code: 'POP_BIRTHRES_ES_DIFF_CCAA', name: 'Different Region' },
				{ code: 'POP_BIRTHRES_FOREIGN', name: 'Foreign Born' }
			];

			migrationPatterns.forEach(pattern => {
				const data = rows.find(r => r.indicator_code === pattern.code);
				console.log(`Looking for ${pattern.code}:`, data);
				if (data && data.value) {
					migrationData.push({
						label: pattern.name,
						value: data.value,
						percentage: (data.value / (data.value + 1000)) * 100 // Approximate percentage
					});
				}
			});

			console.log('Processed migration data:', migrationData);
			return migrationData;
		}

		// Function to handle demographics chart toggle
		function initializeDemographicsControls() {
			console.log('üîß Initializing demographics controls...');
			const chartToggle = document.getElementById('toggleDemographicsChart');
			const tableContainer = document.getElementById('demographicsTableContainer');
			const kpiContainer = document.querySelector('.kpi');
			const genderChart = document.getElementById('genderChart');
			const educationChart = document.getElementById('educationChart');
			const incomeDistributionChart = document.getElementById('incomeDistributionChart');
			const incomeChart = document.getElementById('incomeChart');
			const incomeMap = document.getElementById('incomeMap');
			const ethnicityChart = document.getElementById('ethnicityChart');
			const migrationChart = document.getElementById('migrationChart');
			const ageDistributionChart = document.getElementById('ageDistributionChart');
			
			console.log('Demographics elements found:', {
				chartToggle: !!chartToggle,
				tableContainer: !!tableContainer,
				kpiContainer: !!kpiContainer,
				genderChart: !!genderChart,
				educationChart: !!educationChart,
				incomeDistributionChart: !!incomeDistributionChart,
				incomeChart: !!incomeChart,
				incomeMap: !!incomeMap,
				ethnicityChart: !!ethnicityChart,
				migrationChart: !!migrationChart,
				ageDistributionChart: !!ageDistributionChart
			});
			
			
			if (chartToggle) {
				console.log('‚úÖ Demographics toggle button found and event listener added');
				chartToggle.addEventListener('click', function() {
					console.log('üîÑ Demographics chart toggle clicked');
					console.log('Current isChartView:', isChartView);
					
					isChartView = !isChartView;
					console.log('New isChartView:', isChartView);
					
					if (isChartView) {
						// Switch to table view
						console.log('üìä Switching to TABLE view');
						if (kpiContainer) kpiContainer.style.display = 'none';
						if (genderChart && genderChart.parentElement) genderChart.parentElement.style.display = 'none';
						if (educationChart && educationChart.parentElement) educationChart.parentElement.style.display = 'none';
						if (incomeDistributionChart && incomeDistributionChart.parentElement) incomeDistributionChart.parentElement.style.display = 'none';
						if (incomeChart && incomeChart.parentElement) incomeChart.parentElement.style.display = 'none';
						if (incomeMap && incomeMap.parentElement) incomeMap.parentElement.style.display = 'none';
						if (ethnicityChart && ethnicityChart.parentElement) ethnicityChart.parentElement.style.display = 'none';
						if (migrationChart && migrationChart.parentElement) migrationChart.parentElement.style.display = 'none';
						if (ageDistributionChart && ageDistributionChart.parentElement) ageDistributionChart.parentElement.style.display = 'none';
						if (tableContainer) tableContainer.style.display = 'block';
						if (chartToggle) chartToggle.textContent = 'Switch to Chart View';
						
						console.log('Table container display set to:', tableContainer ? tableContainer.style.display : 'tableContainer not found');
						
						// Destroy charts if they exist
						if (window.genderChartInstance) {
							window.genderChartInstance.destroy();
							window.genderChartInstance = null;
						}
						if (window.educationChartInstance) {
							window.educationChartInstance.destroy();
							window.educationChartInstance = null;
						}
						if (window.incomeDistributionChartInstance) {
							window.incomeDistributionChartInstance.destroy();
							window.incomeDistributionChartInstance = null;
						}
						if (window.incomeChartInstance) {
							window.incomeChartInstance.destroy();
							window.incomeChartInstance = null;
						}
						if (window.ethnicityChartInstance) {
							window.ethnicityChartInstance.destroy();
							window.ethnicityChartInstance = null;
						}
						if (window.migrationChartInstance) {
							window.migrationChartInstance.destroy();
							window.migrationChartInstance = null;
						}
						
						// Render table view
						renderDemographicsTable();
					} else {
						// Switch to chart view (default)
						console.log('üìà Switching to CHART view');
						if (kpiContainer) kpiContainer.style.display = 'block';
						if (genderChart && genderChart.parentElement) genderChart.parentElement.style.display = 'block';
						if (educationChart && educationChart.parentElement) educationChart.parentElement.style.display = 'block';
						if (incomeDistributionChart && incomeDistributionChart.parentElement) incomeDistributionChart.parentElement.style.display = 'block';
						if (incomeChart && incomeChart.parentElement) incomeChart.parentElement.style.display = 'block';
						if (incomeMap && incomeMap.parentElement) incomeMap.parentElement.style.display = 'block';
						if (ethnicityChart && ethnicityChart.parentElement) ethnicityChart.parentElement.style.display = 'block';
						if (migrationChart && migrationChart.parentElement) migrationChart.parentElement.style.display = 'block';
						if (ageDistributionChart && ageDistributionChart.parentElement) ageDistributionChart.parentElement.style.display = 'block';
						if (tableContainer) tableContainer.style.display = 'none';
						if (chartToggle) chartToggle.textContent = 'Switch to Table View';
						
						console.log('Table container display set to:', tableContainer ? tableContainer.style.display : 'tableContainer not found');
						
						// Re-render charts if data is available
						if (demographicsData) {
							renderGenderChart(demographicsData);
							// Education chart needs SeccStats data, not filtered demographics data
							if (window.lastApiResponse && window.lastApiResponse.data && window.lastApiResponse.data.secc_stats && window.lastApiResponse.data.secc_stats.rows) {
								renderEducationStackedChart(window.lastApiResponse.data.secc_stats.rows);
								renderIncomeDistributionChart(window.lastApiResponse.data.secc_stats.rows);
							}
							renderIncomeClusteredChart(demographicsData);
							// Note: Ethnicity and migration charts need raw data, not filtered data
							// They will be re-rendered when new search is performed
						}
					}
				});
			}
		}

		// Function to render demographics table (for table view)
		function renderDemographicsTable() {
			console.log('üîß renderDemographicsTable called');
			console.log('Demographics data available:', !!demographicsData);
			if (!demographicsData) {
				console.log('‚ùå No demographics data available for table');
				return;
			}
			console.log('‚úÖ Rendering demographics table with', demographicsData.length, 'items');

			const tbody = document.getElementById('demographicsTableBody');
			
			// Clear before inserting new rows
			tbody.innerHTML = "";
			
			let currentCategory = null;
			
			// Loop through sorted data and populate table with grouping
			demographicsData.forEach(r => {
				// Add category separator if category changed
				if (currentCategory !== r.category) {
					const separatorRow = `
						<tr class="category-separator">
							<td colspan="5">${r.category}</td>
						</tr>
					`;
					tbody.insertAdjacentHTML("beforeend", separatorRow);
					currentCategory = r.category;
				}
				
				// Format the value
				let formattedValue = r.value || '-';
				if (typeof r.value === 'number') {
					// Add ‚Ç¨ symbol for income indicators
					if (r.category === 'Income') {
						formattedValue = '‚Ç¨' + r.value.toLocaleString();
					} else {
						// Format numbers with commas for population/education
						formattedValue = r.value.toLocaleString();
					}
				}
				
				// Check if this row should be highlighted
				const isHighlighted = r.label === 'Tertiary education' || r.label === 'Mean equivalised net income (‚Ç¨)';
				const rowClass = isHighlighted ? 'highlight-row' : '';
				
				const row = `
					<tr class="${rowClass}">
						<td>${r.category}</td>
						<td>${r.label}</td>
						<td>${formattedValue}</td>
						<td>${r.year || '-'}</td>
						<td>${r.source || '-'}</td>
					</tr>
				`;
				tbody.insertAdjacentHTML("beforeend", row);
			});
			
			// Add ethnicity and migration data to the table
			addEthnicityDataToTable(tbody);
			
			console.log(`Populated demographics table with ${demographicsData.length} indicators`);
		}

		// Function to add ethnicity data to the demographics table
		function addEthnicityDataToTable(tbody) {
			// Get ethnicity data from the stored API response
			if (window.lastApiResponse && window.lastApiResponse.data && window.lastApiResponse.data.secc_stats && window.lastApiResponse.data.secc_stats.rows) {
				const rows = window.lastApiResponse.data.secc_stats.rows;
				const ethnicityData = processEthnicityData(rows);
				const migrationData = processMigrationData(rows);
				
				let ethnicitySection = `
					<tr class="category-separator">
						<td colspan="5">Ethnicity & Migration</td>
					</tr>
				`;
				
				// Add ethnicity data
				ethnicityData.forEach(item => {
					ethnicitySection += `
						<tr>
							<td>Ethnicity & Migration</td>
							<td>${item.label}</td>
							<td>${item.value.toLocaleString()} (${item.percentage.toFixed(1)}%)</td>
							<td>2022</td>
							<td>INE Padr√≥n continuo</td>
						</tr>
					`;
				});
				
				// Add migration data
				migrationData.forEach(item => {
					ethnicitySection += `
						<tr>
							<td>Migration Patterns</td>
							<td>${item.label}</td>
							<td>${item.value.toLocaleString()} (${item.percentage.toFixed(1)}%)</td>
							<td>2022</td>
							<td>INE Padr√≥n continuo</td>
						</tr>
					`;
				});
				
				tbody.insertAdjacentHTML("beforeend", ethnicitySection);
			} else {
				// Fallback to placeholder if no data available
				const ethnicitySection = `
					<tr class="category-separator">
						<td colspan="5">Ethnicity & Migration</td>
					</tr>
					<tr>
						<td>Ethnicity & Migration</td>
						<td>No data available</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
					</tr>
				`;
				tbody.insertAdjacentHTML("beforeend", ethnicitySection);
			}
		}

		// Process Infrastructure Data
		function processInfrastructureData(data) {
			try {
				console.log('Processing infrastructure data...');
				console.log('Full API response data structure:', data);
				
				let infrastructureData = null;
				
				// Check if infrastructure data exists in API response
				if (data && data.data && data.data.infrastructure) {
					console.log('Found infrastructure data in API response');
					infrastructureData = data.data.infrastructure;
				} else {
					console.log('No infrastructure data found in API response');
					console.log('Available data keys:', data && data.data ? Object.keys(data.data) : 'No data');
					
					// Use sample data for testing UI
					console.log('Using sample infrastructure data for testing...');
					infrastructureData = {
						by_type: {
							hospital: 3,
							pharmacy: 8,
							school: 5,
							supermarket: 4
						},
						rows: [
							{
								name_infra: "Hospital General",
								type_infra: "hospital",
								address_infra: "Calle Principal 123",
								url_infra: "https://example.com/hospital1",
								latitude_infra: 36.7201,
								longitude_infra: -4.4203
							},
							{
								name_infra: "Farmacia Central",
								type_infra: "pharmacy",
								address_infra: "Avenida Mayor 45",
								url_infra: "https://example.com/pharmacy1",
								latitude_infra: 36.7150,
								longitude_infra: -4.4150
							},
							{
								name_infra: "Escuela Primaria",
								type_infra: "school",
								address_infra: "Plaza de la Educaci√≥n 12",
								url_infra: "https://example.com/school1",
								latitude_infra: 36.7250,
								longitude_infra: -4.4250
							},
							{
								name_infra: "Supermercado Local",
								type_infra: "supermarket",
								address_infra: "Calle Comercial 78",
								url_infra: "https://example.com/supermarket1",
								latitude_infra: 36.7100,
								longitude_infra: -4.4100
							}
						]
					};
				}
				
				// Store infrastructure data globally for filtering
				allInfrastructureData = infrastructureData;
				
				console.log('Processing infrastructure data:', infrastructureData);
				
				// Update KPI counters
				updateInfrastructureKPIs(infrastructureData);
				
				// Update infrastructure table
				updateInfrastructureTable(infrastructureData);
				
				// Initialize map (placeholder for now)
				initializeInfrastructureMap(infrastructureData);
				
			} catch (error) {
				console.error('Error processing infrastructure data:', error);
				// Even if there's an error, show sample data
				console.log('Error occurred, showing sample data...');
				updateInfrastructureKPIs({
					by_type: { hospital: 3, pharmacy: 8, school: 5, supermarket: 4 }
				});
			}
		}
		
		// Update Infrastructure KPI Counters
		function updateInfrastructureKPIs(data) {
			const kpiCounters = document.querySelectorAll('#infrastructureKPIs .kpi-counter');
			
			console.log('Updating infrastructure KPIs with data:', data);
			
			if (data && data.by_type) {
				// Parse the array format from API
				const counts = {
					hospital: 0,
					pharmacy: 0,
					school: 0,
					supermarket: 0
				};
				
				// Process the by_type array
				if (Array.isArray(data.by_type)) {
					data.by_type.forEach(item => {
						const type = item.type_infra.toLowerCase();
						if (type.includes('hospital')) {
							counts.hospital = item.n;
						} else if (type.includes('pharmacy')) {
							counts.pharmacy = item.n;
						} else if (type.includes('school')) {
							counts.school = item.n;
						} else if (type.includes('supermarkt') || type.includes('supermarket')) {
							counts.supermarket = item.n;
						}
					});
				} else {
					// Fallback for object format
					counts.hospital = data.by_type.hospital || 0;
					counts.pharmacy = data.by_type.pharmacy || 0;
					counts.school = data.by_type.school || 0;
					counts.supermarket = data.by_type.supermarket || 0;
				}
				
				console.log('Setting KPI counts:', counts);
				
				kpiCounters[0].querySelector('div').textContent = counts.hospital;
				kpiCounters[1].querySelector('div').textContent = counts.pharmacy;
				kpiCounters[2].querySelector('div').textContent = counts.school;
				kpiCounters[3].querySelector('div').textContent = counts.supermarket;
			} else {
				console.log('No by_type data found, using fallback counts');
				// Fallback to sample data if no data provided
				kpiCounters[0].querySelector('div').textContent = 3;
				kpiCounters[1].querySelector('div').textContent = 8;
				kpiCounters[2].querySelector('div').textContent = 5;
				kpiCounters[3].querySelector('div').textContent = 4;
			}
		}
		
		// Update Infrastructure Table
		function updateInfrastructureTable(data) {
			const tableContainer = document.getElementById('infrastructureTable');
			
			if (!data.rows || data.rows.length === 0) {
				tableContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #6b7280;">No infrastructure data available</div>';
				return;
			}
			
			const tableHTML = `
				<table style="width: 100%; border-collapse: collapse;">
					<thead>
						<tr style="background: #f8f9fa; border-bottom: 1px solid #dee2e6;">
							<th style="padding: 8px 12px; text-align: left; font-size: 12px; font-weight: 600;">Name</th>
							<th style="padding: 8px 12px; text-align: left; font-size: 12px; font-weight: 600;">Type</th>
							<th style="padding: 8px 12px; text-align: left; font-size: 12px; font-weight: 600;">Address</th>
							<th style="padding: 8px 12px; text-align: left; font-size: 12px; font-weight: 600;">Link</th>
						</tr>
					</thead>
					<tbody>
						${data.rows.map(item => `
							<tr style="border-bottom: 1px solid #f1f5f9;">
								<td style="padding: 8px 12px; font-size: 12px;">${item.name_infra || 'N/A'}</td>
								<td style="padding: 8px 12px; font-size: 12px;">
									<span style="padding: 2px 6px; border-radius: 4px; font-size: 10px; text-transform: capitalize; background: ${getTypeColor(item.type_infra)}; color: white;">
										${item.type_infra || 'N/A'}
									</span>
								</td>
								<td style="padding: 8px 12px; font-size: 12px;">${item.address_infra || 'N/A'}</td>
								<td style="padding: 8px 12px; font-size: 12px;">
									${item.url_infra ? `<a href="${item.url_infra}" target="_blank" style="color: #488E98; text-decoration: none;">Visit</a>` : 'N/A'}
								</td>
							</tr>
						`).join('')}
					</tbody>
				</table>
			`;
			
			tableContainer.innerHTML = tableHTML;
		}
		
		// Get color for infrastructure type
		function getTypeColor(type) {
			const colors = {
				hospital: '#dc2626',
				pharmacy: '#059669',
				school: '#2563eb',
				supermarket: '#7c3aed'
			};
			return colors[type] || '#6b7280';
		}
		
		// Create Infrastructure Charts
		function createInfrastructureCharts(data) {
			if (!data.by_type) return;
			
			// Bar Chart
			createInfrastructureBarChart(data.by_type);
			
			// Pie Chart
			createInfrastructurePieChart(data.by_type);
		}
		
		// Create Infrastructure Bar Chart
		function createInfrastructureBarChart(data) {
			const ctx = document.getElementById('infrastructureBarChart');
			if (!ctx) return;
			
			const chartData = {
				labels: ['Hospitals', 'Pharmacies', 'Schools', 'Supermarkets'],
				datasets: [{
					label: 'Count',
					data: [
						data.hospital || 0,
						data.pharmacy || 0,
						data.school || 0,
						data.supermarket || 0
					],
					backgroundColor: ['#dc2626', '#059669', '#2563eb', '#7c3aed'],
					borderColor: ['#dc2626', '#059669', '#2563eb', '#7c3aed'],
					borderWidth: 1
				}]
			};
			
			const config = {
				type: 'bar',
				data: chartData,
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							display: false
						}
					},
					scales: {
						y: {
							beginAtZero: true,
							ticks: {
								stepSize: 1
							}
						}
					}
				}
			};
			
			new Chart(ctx, config);
		}
		
		// Create Infrastructure Pie Chart
		function createInfrastructurePieChart(data) {
			const ctx = document.getElementById('infrastructurePieChart');
			if (!ctx) return;
			
			const total = (data.hospital || 0) + (data.pharmacy || 0) + (data.school || 0) + (data.supermarket || 0);
			
			if (total === 0) {
				ctx.getContext('2d').fillText('No data', ctx.width/2, ctx.height/2);
				return;
			}
			
			const chartData = {
				labels: ['Hospitals', 'Pharmacies', 'Schools', 'Supermarkets'],
				datasets: [{
					data: [
						data.hospital || 0,
						data.pharmacy || 0,
						data.school || 0,
						data.supermarket || 0
					],
					backgroundColor: ['#dc2626', '#059669', '#2563eb', '#7c3aed'],
					borderColor: ['#dc2626', '#059669', '#2563eb', '#7c3aed'],
					borderWidth: 1
				}]
			};
			
			const config = {
				type: 'pie',
				data: chartData,
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							position: 'bottom',
							labels: {
								padding: 10,
								usePointStyle: true,
								font: {
									size: 10
								}
							}
						}
					}
				}
			};
			
			new Chart(ctx, config);
		}
		
		// Global map variable
		let infrastructureMap = null;
		
		// City coordinates database
		const cityCoordinates = {
			'malaga': [36.7213, -4.4214],
			'ronda': [36.7423, -5.1669],
			'madrid': [40.4168, -3.7038],
			'barcelona': [41.3851, 2.1734],
			'valencia': [39.4699, -0.3763],
			'seville': [37.3891, -5.9845],
			'bilbao': [43.2627, -2.9253],
			'zaragoza': [41.6488, -0.8891],
			'murcia': [37.9922, -1.1307],
			'palma': [39.5696, 2.6502],
			'las palmas': [28.1248, -15.4300],
			'alicante': [38.3452, -0.4810],
			'cordoba': [37.8882, -4.7794],
			'valladolid': [41.6523, -4.7245],
			'vigo': [42.2406, -8.7207],
			'gijon': [43.5357, -5.6615],
			'vitoria': [42.8467, -2.6716],
			'coruna': [43.3713, -8.3960],
			'granada': [37.1773, -3.5986],
			'oviedo': [43.3614, -5.8593],
			'santander': [43.4623, -3.8099],
			'pamplona': [42.8182, -1.6443],
			'almeria': [36.8408, -2.4597],
			'logrono': [42.4627, -2.4449],
			'burgos': [42.3409, -3.6997],
			'salamanca': [40.9701, -5.6635],
			'albacete': [38.9942, -1.8584],
			'getafe': [40.3047, -3.7319],
			'cartagena': [37.6057, -0.9864],
			'jerez': [36.6860, -6.1360],
			'guadalajara': [40.6289, -3.1693],
			'pontevedra': [42.4336, -8.6481],
			'ferrol': [43.4833, -8.2333],
			'ourense': [42.3400, -7.8647],
			'lugo': [43.0099, -7.5560],
			'leon': [42.5987, -5.5671],
			'ponferrada': [42.5466, -6.5962],
			'zamora': [41.5035, -5.7448],
			'avila': [40.6566, -4.6812],
			'segovia': [40.9494, -4.1192],
			'soria': [41.7665, -2.4790],
			'huesca': [42.1401, -0.4089],
			'teruel': [40.3456, -1.1065],
			'cuenca': [40.0718, -2.1340],
			'toledo': [39.8628, -4.0273],
			'ciudad real': [38.9860, -3.9290],
			'badajoz': [38.8794, -6.9707],
			'caceres': [39.4753, -6.3724],
			'merida': [38.9160, -6.3437],
			'jaen': [37.7796, -3.7849],
			'cadiz': [36.5298, -6.2934],
			'huelva': [37.2578, -6.9507],
			'ceuta': [35.8883, -5.3162],
			'melilla': [35.2923, -2.9381]
		};
		
		// Initialize Infrastructure Map with Leaflet
		function initializeInfrastructureMap(data) {
			const mapContainer = document.getElementById('infrastructureMap');
			
			// Clear existing map
			if (infrastructureMap) {
				infrastructureMap.remove();
				infrastructureMap = null;
			}
			
			// Use a default center for initial map view (will be adjusted by fitBounds)
			// Default to search center if available, otherwise use first infrastructure marker
			let mapCenter = [40.4168, -3.7038]; // Generic default (will be overridden by fitBounds)
			let mapZoom = 13;
			
			if (searchCenter && searchCenter.lat && searchCenter.lon) {
				// Use actual search center coordinates
				mapCenter = [searchCenter.lat, searchCenter.lon];
				console.log('Using search center coordinates for initial view:', mapCenter);
			} else if (data && data.rows && data.rows.length > 0) {
				// If no search center, use first infrastructure marker location for initial view
				const firstMarker = data.rows.find(item => item.latitude_infra && item.longitude_infra);
				if (firstMarker) {
					mapCenter = [parseFloat(firstMarker.latitude_infra), parseFloat(firstMarker.longitude_infra)];
					console.log('Using first infrastructure marker for initial view:', mapCenter);
				}
			}
			
			// Initialize Leaflet map
			infrastructureMap = L.map('infrastructureMap').setView(mapCenter, mapZoom);
			
			// Add OpenStreetMap tiles
			L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				attribution: '¬© OpenStreetMap contributors',
				maxZoom: 19
			}).addTo(infrastructureMap);
			
			// Collect all marker coordinates for bounds calculation
			const markerBounds = [];
			
			// Add infrastructure markers if data exists
			if (data && data.rows && data.rows.length > 0) {
				console.log('Adding infrastructure markers:', data.rows.length);
				
				data.rows.forEach((item, index) => {
					// Use real coordinates from API
					if (item.latitude_infra && item.longitude_infra) {
						const markerCoords = [parseFloat(item.latitude_infra), parseFloat(item.longitude_infra)];
						
						// Add to bounds
						markerBounds.push(markerCoords);
						
						const color = getTypeColor(item.type_infra);
						const icon = L.divIcon({
							className: 'infrastructure-marker',
							html: `<div style="background: ${color}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
							iconSize: [12, 12],
							iconAnchor: [6, 6]
						});
						
						const marker = L.marker(markerCoords, { icon: icon })
							.addTo(infrastructureMap)
							.bindPopup(`
								<div style="min-width: 200px;">
									<h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">${item.name_infra || 'Unknown'}</h4>
									<div style="margin-bottom: 4px;">
										<span style="padding: 2px 6px; border-radius: 4px; font-size: 10px; text-transform: capitalize; background: ${color}; color: white;">
											${item.type_infra || 'Unknown'}
										</span>
									</div>
									<p style="margin: 4px 0; font-size: 12px; color: #6b7280;">${item.address_infra || 'Address not available'}</p>
									${item.url_infra ? `<a href="${item.url_infra}" target="_blank" style="color: #488E98; text-decoration: none; font-size: 12px;">Visit Website ‚Üí</a>` : ''}
									<div style="margin-top: 8px; font-size: 10px; color: #9ca3af;">
										üìç ${markerCoords[0].toFixed(6)}, ${markerCoords[1].toFixed(6)}
									</div>
								</div>
							`);
						
						console.log(`Added marker for ${item.name_infra} at coordinates:`, markerCoords);
					} else {
						console.warn(`No coordinates found for ${item.name_infra}`);
					}
				});
			} else {
				console.log('No infrastructure data available for markers');
			}
			
			// Fit map bounds to show all markers
			if (markerBounds.length > 0) {
				const bounds = L.latLngBounds(markerBounds);
				infrastructureMap.fitBounds(bounds, { padding: [50, 50], maxZoom: 17 });
				console.log('Fitted map bounds to show all markers:', markerBounds.length);
			}
			
			// Add legend
			const legend = L.control({ position: 'bottomright' });
			legend.onAdd = function(map) {
				const div = L.DomUtil.create('div', 'map-legend');
				div.style.cssText = `
					background: rgba(255,255,255,0.9); 
					padding: 8px; 
					border-radius: 4px; 
					font-size: 10px; 
					box-shadow: 0 2px 4px rgba(0,0,0,0.2);
				`;
				div.innerHTML = `
					<div style="margin-bottom: 4px; font-weight: 600;">Legend:</div>
					<div style="display: flex; align-items: center; margin-bottom: 2px;">
						<div style="width: 8px; height: 8px; background: #dc2626; border-radius: 50%; margin-right: 4px;"></div>
						<span>Hospitals</span>
					</div>
					<div style="display: flex; align-items: center; margin-bottom: 2px;">
						<div style="width: 8px; height: 8px; background: #059669; border-radius: 50%; margin-right: 4px;"></div>
						<span>Pharmacies</span>
					</div>
					<div style="display: flex; align-items: center; margin-bottom: 2px;">
						<div style="width: 8px; height: 8px; background: #2563eb; border-radius: 50%; margin-right: 4px;"></div>
						<span>Schools</span>
					</div>
					<div style="display: flex; align-items: center;">
						<div style="width: 8px; height: 8px; background: #7c3aed; border-radius: 50%; margin-right: 4px;"></div>
						<span>Supermarkets</span>
					</div>
				`;
				return div;
			};
			legend.addTo(infrastructureMap);
		}
		
		// Function to show marker info (called when marker is clicked)
		function showMarkerInfo(name, type, address, url) {
			const info = `
				<div style="background: white; padding: 12px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); max-width: 300px;">
					<h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">${name}</h4>
					<div style="margin-bottom: 4px;">
						<span style="padding: 2px 6px; border-radius: 4px; font-size: 10px; text-transform: capitalize; background: ${getTypeColor(type)}; color: white;">
							${type}
						</span>
					</div>
					<p style="margin: 4px 0; font-size: 12px; color: #6b7280;">${address}</p>
					${url ? `<a href="${url}" target="_blank" style="color: #488E98; text-decoration: none; font-size: 12px;">Visit Website ‚Üí</a>` : ''}
				</div>
			`;
			
			// Create a simple popup (in a real implementation, use a proper popup library)
			const popup = document.createElement('div');
			popup.innerHTML = info;
			popup.style.cssText = `
				position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
				z-index: 1000; background: rgba(0,0,0,0.5); width: 100%; height: 100%;
				display: flex; align-items: center; justify-content: center;
			`;
			
			popup.onclick = function() {
				document.body.removeChild(popup);
			};
			
			document.body.appendChild(popup);
		}
		
		// Global variable to store all infrastructure data
		let allInfrastructureData = null;
		
		// Initialize Infrastructure Controls
		function initializeInfrastructureControls() {
			const filter = document.getElementById('infrastructureFilter');
			if (filter) {
				filter.addEventListener('change', function() {
					const selectedType = this.value;
					console.log('Infrastructure filter changed to:', selectedType);
					
					// Filter and update both map and table
					filterInfrastructure(selectedType);
				});
			}
		}
		
		// Filter infrastructure data and update map and table
		function filterInfrastructure(selectedType) {
			if (!allInfrastructureData) {
				console.log('No infrastructure data available for filtering');
				return;
			}
			
			let filteredData = null;
			
			if (selectedType === 'all') {
				// Show all infrastructure
				filteredData = allInfrastructureData;
			} else {
				// Filter by type
				const filteredRows = allInfrastructureData.rows.filter(item => {
					const itemType = item.type_infra.toLowerCase();
					
					switch (selectedType) {
						case 'hospital':
							return itemType.includes('hospital');
						case 'pharmacy':
							return itemType.includes('pharmacy');
						case 'school':
							return itemType.includes('school');
						case 'supermarket':
							return itemType.includes('supermarkt') || itemType.includes('supermarket');
						default:
							return true;
					}
				});
				
				// Recalculate by_type counts for filtered data
				const byTypeCounts = {
					hospital: 0,
					pharmacy: 0,
					school: 0,
					supermarket: 0
				};
				
				filteredRows.forEach(item => {
					const itemType = item.type_infra.toLowerCase();
					if (itemType.includes('hospital')) byTypeCounts.hospital++;
					else if (itemType.includes('pharmacy')) byTypeCounts.pharmacy++;
					else if (itemType.includes('school')) byTypeCounts.school++;
					else if (itemType.includes('supermarkt') || itemType.includes('supermarket')) byTypeCounts.supermarket++;
				});
				
				filteredData = {
					rows: filteredRows,
					by_type: byTypeCounts
				};
			}
			
			console.log(`Filtered infrastructure: ${filteredData.rows.length} items of type '${selectedType}'`);
			
			// Update KPI counters
			updateInfrastructureKPIs(filteredData);
			
			// Update infrastructure table
			updateInfrastructureTable(filteredData);
			
			// Update map markers
			updateMapMarkers(filteredData);
		}
		
		// Update map markers based on filtered data
		function updateMapMarkers(data) {
			if (!infrastructureMap) {
				console.log('Map not initialized yet');
				return;
			}
			
			// Remove all existing infrastructure markers
			infrastructureMap.eachLayer(function(layer) {
				if (layer.options && layer.options.icon && layer.options.icon.options && layer.options.icon.options.className === 'infrastructure-marker') {
					infrastructureMap.removeLayer(layer);
				}
			});
			
			// Collect marker coordinates for bounds calculation
			const markerBounds = [];
			
			// Add filtered markers
			if (data && data.rows && data.rows.length > 0) {
				console.log('Adding filtered markers to map:', data.rows.length);
				
				data.rows.forEach((item, index) => {
					if (item.latitude_infra && item.longitude_infra) {
						const markerCoords = [parseFloat(item.latitude_infra), parseFloat(item.longitude_infra)];
						
						// Add to bounds
						markerBounds.push(markerCoords);
						
						const color = getTypeColor(item.type_infra);
						const icon = L.divIcon({
							className: 'infrastructure-marker',
							html: `<div style="background: ${color}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
							iconSize: [12, 12],
							iconAnchor: [6, 6]
						});
						
						const marker = L.marker(markerCoords, { icon: icon })
							.addTo(infrastructureMap)
							.bindPopup(`
								<div style="min-width: 200px;">
									<h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">${item.name_infra || 'Unknown'}</h4>
									<div style="margin-bottom: 4px;">
										<span style="padding: 2px 6px; border-radius: 4px; font-size: 10px; text-transform: capitalize; background: ${color}; color: white;">
											${item.type_infra || 'Unknown'}
										</span>
									</div>
									<p style="margin: 4px 0; font-size: 12px; color: #6b7280;">${item.address_infra || 'Address not available'}</p>
									${item.url_infra ? `<a href="${item.url_infra}" target="_blank" style="color: #488E98; text-decoration: none; font-size: 12px;">Visit Website ‚Üí</a>` : ''}
									<div style="margin-top: 8px; font-size: 10px; color: #9ca3af;">
										üìç ${markerCoords[0].toFixed(6)}, ${markerCoords[1].toFixed(6)}
									</div>
								</div>
							`);
					}
				});
			}
			
			// Fit map bounds to show all filtered markers
			if (markerBounds.length > 0) {
				const bounds = L.latLngBounds(markerBounds);
				infrastructureMap.fitBounds(bounds, { padding: [50, 50], maxZoom: 17 });
				console.log('Fitted map bounds to show filtered markers:', markerBounds.length);
			}
		}

		// Global variables for comparison
		let selectedProperties = [];
		
		// Clear selected properties on page load to prevent restoration
		if (typeof window !== 'undefined') {
			window.addEventListener('beforeunload', function() {
				// Clear selected properties when leaving the page
				if (typeof AppState !== 'undefined' && AppState.setSelectedProperties) {
					AppState.setSelectedProperties([]);
				}
			});
		}
		// allPropertyData is already declared above in the existing code
		
		// Track if event listeners are already registered to prevent duplicates
		let comparisonControlsInitialized = false;
		
		// Initialize comparison functionality
		function initializeComparisonControls() {
			// Prevent multiple initializations
			if (comparisonControlsInitialized) {
				console.log('[Compare] Controls already initialized, skipping...');
				return;
			}
			
			const compareButton = document.getElementById('compareButton');
			const clearSelection = document.getElementById('clearSelection');
			const compareControls = document.getElementById('compareControls');
			
			if (compareButton && clearSelection && compareControls) {
				// Remove any existing listeners first (cleanup)
				const newCompareButton = compareButton.cloneNode(true);
				compareButton.parentNode.replaceChild(newCompareButton, compareButton);
				const newClearButton = clearSelection.cloneNode(true);
				clearSelection.parentNode.replaceChild(newClearButton, clearSelection);
				
				// Get fresh references after cloning
				const freshCompareButton = document.getElementById('compareButton');
				const freshClearButton = document.getElementById('clearSelection');
				
				// Compare button click handler
				freshCompareButton.addEventListener('click', function() {
					console.log('[Compare] Compare button clicked, selectedProperties count:', selectedProperties.length);
					console.log('[Compare] Selected properties:', selectedProperties.map(p => p.compareId));
					
					if (selectedProperties.length >= 2) {
						// Ensure no duplicates before storing
						const uniqueProperties = [];
						const seenIds = new Set();
						selectedProperties.forEach(prop => {
							if (!seenIds.has(prop.compareId)) {
								seenIds.add(prop.compareId);
								uniqueProperties.push(prop);
							}
						});
						
						if (uniqueProperties.length < 2) {
							alert('Please select 2 different properties to compare');
							return;
						}
						
						console.log('[Compare] Unique properties:', uniqueProperties.length);
						console.log('[Compare] originalPropertyData length:', originalPropertyData.length);
						
					// Get property indices from the original unfiltered data
					// The compareId tells us the display index (p1, p2, etc.), but we need the index in originalPropertyData
					const propertyIndices = [];
					
					uniqueProperties.forEach(item => {
						const property = item.property;
						let foundIndex = -1;
						
						console.log('[Compare] Looking for property:', {
							price: property.price_amount,
							sqm: property.sqm,
							rooms: property.rooms,
							location: property.location_optimized
						});
						
						// First, try to find by exact object reference
						foundIndex = originalPropertyData.findIndex(p => p === property);
						
						// If not found, try matching by key properties (more reliable)
						if (foundIndex < 0) {
							foundIndex = originalPropertyData.findIndex(p => {
								// Match by multiple key properties to ensure uniqueness
								const match = p.price_amount === property.price_amount &&
										   (p.sqm || 0) === (property.sqm || 0) &&
										   (p.rooms || 0) === (property.rooms || 0) &&
										   (p.location_optimized || '') === (property.location_optimized || '');
								return match;
							});
						}
						
						// If still not found, try matching by compareId if it contains the index
						if (foundIndex < 0 && item.compareId) {
							const compareIdMatch = item.compareId.match(/p(\d+)/);
							if (compareIdMatch) {
								const displayIndex = parseInt(compareIdMatch[1]) - 1; // p1 = 0, p2 = 1, etc.
								// This is the index in the displayed/filtered list, we need originalPropertyData index
								// The property should match the one at that position in allPropertyData when selected
								// Try to find it by matching the property object
								const tempIndex = originalPropertyData.findIndex(p => {
									return p === property || (
										p.price_amount === property.price_amount &&
										Math.abs((p.sqm || 0) - (property.sqm || 0)) < 0.01 &&
										(p.rooms || 0) === (property.rooms || 0)
									);
								});
								if (tempIndex >= 0) {
									foundIndex = tempIndex;
								}
							}
						}
						
						// Last fallback: use stored index if it's valid
						if (foundIndex < 0 && item.index !== undefined && item.index >= 0 && item.index < originalPropertyData.length) {
							foundIndex = item.index;
							console.log('[Compare] Using stored index as fallback:', foundIndex);
						}
						
						if (foundIndex >= 0 && foundIndex < originalPropertyData.length) {
							propertyIndices.push(foundIndex);
							console.log('[Compare] ‚úÖ Found property at index', foundIndex);
						} else {
							console.error('[Compare] ‚ùå Could not find property index for:', property);
							console.error('[Compare] Property details:', {
								price: property.price_amount,
								sqm: property.sqm,
								rooms: property.rooms,
								location: property.location_optimized,
								storedIndex: item.index,
								compareId: item.compareId
							});
						}
					});
						
						console.log('[Compare] Property indices found:', propertyIndices);
						
						if (propertyIndices.length < 2) {
							console.error('[Compare] ‚ùå Could not find valid indices for properties');
							alert('Error: Could not identify selected properties. Please try again.');
							return;
						}
						
						// Ensure API response is stored in AppState with current property data AND secc_stats
						if (typeof AppState !== 'undefined') {
							// Get existing API response to preserve secc_stats
							const existingApiResponse = AppState.getApiResponse();
							
							// Update API response with current properties, but preserve secc_stats and other data
							const apiResponse = existingApiResponse || {};
							if (!apiResponse.data) {
								apiResponse.data = {};
							}
							
							// Update properties with current originalPropertyData
							apiResponse.data.properties = {
								rows: originalPropertyData
							};
							
							// Preserve secc_stats if it exists
							if (existingApiResponse && existingApiResponse.data && existingApiResponse.data.secc_stats) {
								apiResponse.data.secc_stats = existingApiResponse.data.secc_stats;
								console.log('[Compare] Preserved secc_stats with', existingApiResponse.data.secc_stats.rows?.length || 0, 'rows');
							}
							
							// Preserve muni_stats if it exists
							if (existingApiResponse && existingApiResponse.data && existingApiResponse.data.muni_stats) {
								apiResponse.data.muni_stats = existingApiResponse.data.muni_stats;
							}
							
							AppState.setApiResponse(apiResponse);
							console.log('[Compare] API response stored with', originalPropertyData.length, 'properties');
							console.log('[Compare] API response includes secc_stats:', !!apiResponse.data.secc_stats);
							
							// Also store selected properties for fallback
							try {
							AppState.setSelectedProperties(uniqueProperties);
								console.log('[Compare] Selected properties also stored in AppState');
							} catch (e) {
								console.warn('[Compare] Could not store in AppState:', e);
							}
						}
						
						// Pass indices via URL parameters
						const params = new URLSearchParams();
						params.set('p1', propertyIndices[0]);
						params.set('p2', propertyIndices[1]);
						
						// Navigate to compare page with parameters
						console.log('[Compare] Navigating to compare.html with indices:', propertyIndices);
						console.log('[Compare] URL will be: compare.html?' + params.toString());
						window.location.href = 'compare.html?' + params.toString();
					} else {
						alert('Please select at least 2 properties to compare');
					}
				});
				
				// Clear selection button click handler
				freshClearButton.addEventListener('click', function() {
					console.log('[Compare] Clear selection clicked');
					// Uncheck all checkboxes
					const checkboxes = document.querySelectorAll('input[type="checkbox"][data-compare-id]');
					checkboxes.forEach(checkbox => {
						checkbox.checked = false;
					});
					selectedProperties = [];
					updateCompareControls();
				});
				
				// Add event delegation for checkbox changes (only once)
				// Check if listener already exists
				if (!document.comparisonChangeListenerAdded) {
				document.addEventListener('change', function(e) {
					if (e.target.type === 'checkbox' && e.target.hasAttribute('data-compare-id')) {
						handlePropertySelection(e.target);
					}
				});
					document.comparisonChangeListenerAdded = true;
					console.log('[Compare] ‚úÖ Change event listener registered');
				}
				
				comparisonControlsInitialized = true;
				console.log('[Compare] ‚úÖ Comparison controls initialized');
			}
		}
		
		// Handle property selection for comparison
		function handlePropertySelection(checkbox) {
			const compareId = checkbox.getAttribute('data-compare-id');
			const propertyIndex = parseInt(compareId.replace('p', '')) - 1; // Convert p1, p2, etc. to 0, 1, etc.
			
			if (checkbox.checked) {
				// Check if this property is already selected (prevent duplicates)
				const alreadySelected = selectedProperties.some(item => item.compareId === compareId);
				if (alreadySelected) {
					console.log('[Compare] Property already selected:', compareId);
					// Uncheck the checkbox since it's already selected
					checkbox.checked = false;
					return;
				}
				
				// Add to selection (max 2 properties)
				if (selectedProperties.length < 2) {
					if (allPropertyData && allPropertyData[propertyIndex]) {
						selectedProperties.push({
							index: propertyIndex,
							property: allPropertyData[propertyIndex],
							compareId: compareId
						});
						console.log('[Compare] Property added:', compareId, 'Total selected:', selectedProperties.length);
					} else {
						console.error('[Compare] Property data not found for index:', propertyIndex);
						checkbox.checked = false;
						return;
					}
				} else {
					// Uncheck the checkbox if already have 2 selected
					checkbox.checked = false;
					alert('You can only compare up to 2 properties at a time. Please deselect a property first.');
					return;
				}
			} else {
				// Remove from selection
				const beforeLength = selectedProperties.length;
				selectedProperties = selectedProperties.filter(item => item.compareId !== compareId);
				console.log('[Compare] Property removed:', compareId, 'Was:', beforeLength, 'Now:', selectedProperties.length);
			}
			
			updateCompareControls();
		}
		
		// Update comparison controls visibility and count
		function updateCompareControls() {
			const compareControls = document.getElementById('compareControls');
			const selectedCount = document.getElementById('selectedCount');
			const compareButton = document.getElementById('compareButton');
			
			if (compareControls && selectedCount && compareButton) {
				if (selectedProperties.length > 0) {
					compareControls.style.display = 'block';
					selectedCount.textContent = selectedProperties.length;
					
					// Enable/disable compare button based on selection count
					if (selectedProperties.length >= 2) {
						compareButton.disabled = false;
						compareButton.style.opacity = '1';
					} else {
						compareButton.disabled = true;
						compareButton.style.opacity = '0.6';
					}
				} else {
					compareControls.style.display = 'none';
				}
			}
		}

		// Function to download JSON data as a file
		function downloadJsonData(data) {
			try {
				// Create a filename with timestamp
				const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
				const filename = `propintelli-api-response-${timestamp}.json`;
				
				// Convert data to JSON string with proper formatting
				const jsonString = JSON.stringify(data, null, 2);
				
				// Create a blob with the JSON data
				const blob = new Blob([jsonString], { type: 'application/json' });
				
				// Create a download link
				const url = URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.href = url;
				link.download = filename;
				
				// Trigger the download
				document.body.appendChild(link);
				link.click();
				
				// Clean up
				document.body.removeChild(link);
				URL.revokeObjectURL(url);
				
				console.log(`Downloaded JSON file: ${filename}`);
			} catch (error) {
				console.error('Error downloading JSON:', error);
				alert('Error downloading JSON file. Please try again.');
			}
		}
		
		// Initialize listings controls when DOM is loaded
		document.addEventListener('DOMContentLoaded', function() {
			console.log('[Search] üöÄ DOM Content Loaded');
			
			// Wait for AppState to initialize
			function initializePage() {
				// Check if AppState is ready
				if (typeof AppState === 'undefined') {
					console.log('[Search] ‚è≥ Waiting for AppState...');
					setTimeout(initializePage, 100);
					return;
				}
				
				console.log('[Search] ‚úÖ AppState is ready, proceeding with initialization');
				
				// Clear selected properties on page initialization
				selectedProperties = [];
				if (typeof AppState !== 'undefined' && AppState.setSelectedProperties) {
					AppState.setSelectedProperties([]);
					console.log('[Search] ‚úÖ Cleared selected properties on initialization');
				}
				
				// Initialize all controls FIRST (so functions are available)
				console.log('[Search] üîÑ Initializing controls...');
			initializeListingsControls();
			initializeDemographicsControls();
			initializeInfrastructureControls();
			initializeComparisonControls();
			
			// Initialize age toggle buttons
			updateAgeToggleButtons();
				
				console.log('[Search] ‚úÖ Controls initialized');
				
				// Make displayResults globally accessible
				if (typeof displayResults === 'function') {
					window.displayResults = displayResults;
					console.log('[Search] ‚úÖ Made displayResults globally accessible');
				}
				
				// THEN restore page from AppState (after functions are defined)
				console.log('[Search] üîÑ Starting page restoration...');
				setTimeout(function() {
					restorePageFromState();
				}, 150);
				
				console.log('[Search] ‚úÖ Page initialization complete');
			}
			
			// Start initialization
			setTimeout(initializePage, 150);
		});
		
		// Also try to restore when window loads (fallback)
		window.addEventListener('load', function() {
			console.log('[Search] üîÑ Window load event fired');
			setTimeout(function() {
				if (typeof AppState !== 'undefined' && AppState.getApiResponse() && !window.lastApiResponse) {
					console.log('[Search] üîÑ Window load: Attempting to restore state...');
					restorePageFromState();
				}
			}, 200);
		});
		
		// Test if storage is available
		function testStorageAvailability() {
			try {
				const testKey = 'propintelli_storage_test';
				const testValue = 'test_' + Date.now();
				localStorage.setItem(testKey, testValue);
				const retrieved = localStorage.getItem(testKey);
				localStorage.removeItem(testKey);
				
				if (retrieved === testValue) {
					console.log('[Search] ‚úÖ localStorage is WORKING');
					window.propintelliStorageAvailable = true;
				} else {
					console.error('[Search] ‚ùå localStorage test FAILED - retrieved value does not match');
					window.propintelliStorageAvailable = false;
				}
			} catch (error) {
				console.error('[Search] ‚ùå localStorage is NOT available:', error);
				window.propintelliStorageAvailable = false;
				alert('‚ö†Ô∏è localStorage is not available. Data cannot be shared across pages. Error: ' + error.message);
			}
		}
		
		// Restore page from AppState
		function restorePageFromState() {
			console.log('[Search] üîç Checking for stored state...');
			
			// Wait for AppState to be ready
			if (typeof AppState === 'undefined') {
				console.error('[Search] ‚ùå AppState not available! Waiting...');
				// Try again after a short delay
				setTimeout(restorePageFromState, 200);
				return;
			}
			
			console.log('[Search] ‚úÖ AppState is available');
			console.log('[Search] AppState summary:', AppState.getStateSummary());
			
			const apiResponse = AppState.getApiResponse();
			const searchParams = AppState.getSearchParams();
			
			console.log('[Search] üì¶ Retrieving data from AppState...');
			console.log('[Search] API response:', apiResponse ? 'EXISTS' : 'MISSING');
			console.log('[Search] Search params:', searchParams ? 'EXISTS' : 'MISSING');
			
			if (!apiResponse) {
				console.log('[Search] ‚ö†Ô∏è No stored API response found in AppState');
				console.log('[Search] Checking localStorage directly...');
				
				// Fallback: try to load from localStorage directly
				try {
					const stored = localStorage.getItem('propintelli_app_state');
					if (stored) {
						const parsed = JSON.parse(stored);
						console.log('[Search] üì¶ Found state in localStorage:', {
							hasApiResponse: !!parsed.apiResponse,
							hasSearchParams: !!parsed.searchParams,
							keys: Object.keys(parsed)
						});
						
						if (parsed.apiResponse) {
							console.log('[Search] ‚úÖ Found API response in localStorage directly!');
							console.log('[Search] Restoring to AppState...');
							AppState.state.apiResponse = parsed.apiResponse;
							AppState.state.searchParams = parsed.searchParams || searchParams;
							// Recursively call to restore with the newly loaded data
							setTimeout(function() {
								restorePageFromState();
							}, 50);
							return;
						} else {
							console.error('[Search] ‚ùå State exists but no apiResponse field found!');
							console.error('[Search] Available fields:', Object.keys(parsed));
						}
					} else {
						console.error('[Search] ‚ùå No state found in localStorage at all!');
						console.error('[Search] Checking all localStorage keys...');
						const allKeys = Object.keys(localStorage);
						const propKeys = allKeys.filter(k => k.includes('propintelli') || k.includes('api'));
						console.log('[Search] PropIntelli-related keys:', propKeys);
					}
				} catch (error) {
					console.error('[Search] ‚ùå Error checking localStorage:', error);
				}
				console.error('[Search] ‚ùå Cannot restore - no API response found anywhere');
				return;
			}
			
			console.log('[Search] üì¶ Restoring page from AppState...');
			console.log('[Search] API response type:', typeof apiResponse);
			console.log('[Search] API response has data:', !!(apiResponse && apiResponse.data));
			console.log('[Search] API response keys:', apiResponse ? Object.keys(apiResponse).slice(0, 10) : 'N/A');
			console.log('[Search] Search params:', searchParams);
			
			// Restore window variable
			window.lastApiResponse = apiResponse;
			console.log('[Search] ‚úÖ Restored window.lastApiResponse');
			
			// Restore search parameters
			if (searchParams) {
				if (searchParams.lat && searchParams.lon) {
					searchCenter = { lat: searchParams.lat, lon: searchParams.lon };
					searchRadiusKm = searchParams.radius;
					console.log('[Search] ‚úÖ Restored search center:', searchCenter, 'radius:', searchRadiusKm);
				}
				
				// Restore form values if elements exist
				const cityInput = document.getElementById('selectedCity');
				if (cityInput && searchParams.city) {
					cityInput.value = searchParams.city;
					console.log('[Search] ‚úÖ Restored city input:', searchParams.city);
				}
				
				const radiusSelect = document.getElementById('radiusSelect');
				if (radiusSelect && searchParams.radius) {
					radiusSelect.value = searchParams.radius;
					console.log('[Search] ‚úÖ Restored radius select:', searchParams.radius);
				}
			}
			
			// Re-display all results
			console.log('[Search] üîÑ Preparing to re-display stored results...');
			console.log('[Search] Checking if displayResults is defined:', typeof displayResults);
			console.log('[Search] Checking window.displayResults:', typeof window.displayResults);
			
			// Direct restoration function - manually restores everything displayResults does
			function restoreResultsDirectly() {
				console.log('[Search] üîÑ Starting DIRECT restoration...');
				const resultsSection = document.getElementById('resultsSection');
				const resultsJson = document.getElementById('resultsJson');
				const noResults = document.getElementById('noResults');
				
				if (!resultsSection || !resultsJson) {
					console.error('[Search] ‚ùå Required elements not found for direct restoration');
					return false;
				}
				
				// Show results section (currently hidden per user request)
				// resultsSection.style.display = 'block';
				noResults.style.display = 'none';
				
				// Display JSON
				try {
					const jsonString = JSON.stringify(apiResponse, null, 2);
					resultsJson.textContent = jsonString;
					
					// Restore window variable
					window.lastApiResponse = apiResponse;
					
					// Call all the processing functions that displayResults normally calls
					try {
						if (typeof processCrimeData === 'function') processCrimeData(apiResponse);
						if (typeof processPropertyListings === 'function') processPropertyListings(apiResponse);
						if (typeof processMarketAnalytics === 'function') processMarketAnalytics(apiResponse);
						if (typeof processMapView === 'function') processMapView(apiResponse);
						if (typeof processInfrastructureData === 'function') processInfrastructureData(apiResponse);
						
						// Process demographics
						if (apiResponse && apiResponse.data && apiResponse.data.muni_stats && apiResponse.data.muni_stats.rows) {
							if (typeof renderDemographics === 'function') renderDemographics(apiResponse.data.muni_stats.rows);
						}
						
						// Process section stats
						if (apiResponse && apiResponse.data && apiResponse.data.secc_stats && apiResponse.data.secc_stats.rows) {
							const municipalityData = apiResponse.data.muni_stats && apiResponse.data.muni_stats.rows ? apiResponse.data.muni_stats.rows : null;
							if (typeof renderPopulationOverview === 'function') renderPopulationOverview(apiResponse.data.secc_stats.rows, municipalityData);
						}
						
						if (typeof generateAreaSummary === 'function') generateAreaSummary(apiResponse);
					} catch (procError) {
						console.warn('[Search] ‚ö†Ô∏è Some processing functions failed:', procError);
					}
					
					console.log('[Search] ‚úÖ‚úÖ‚úÖ Direct restoration completed successfully');
					return true;
				} catch (error) {
					console.error('[Search] ‚ùå Error in direct restoration:', error);
					return false;
				}
			}
			
			// Wait a bit for displayResults to be defined if it's not ready yet
			function tryDisplayResults() {
				// Try both local and global scope
				const displayFunc = typeof displayResults === 'function' ? displayResults : 
				                   (typeof window !== 'undefined' && typeof window.displayResults === 'function' ? window.displayResults : null);
				
				if (displayFunc) {
					console.log('[Search] ‚úÖ displayResults function is available');
					console.log('[Search] üìä Calling displayResults with API response...');
					console.log('[Search] API response preview:', {
						hasData: !!apiResponse,
						hasDataData: !!(apiResponse && apiResponse.data),
						topKeys: apiResponse ? Object.keys(apiResponse).slice(0, 5) : []
					});
					
					try {
						// Call displayResults with the restored API response
						displayFunc(apiResponse);
						console.log('[Search] ‚úÖ‚úÖ‚úÖ displayResults() call completed');
						
						// Double-check that results section is visible after a short delay
						setTimeout(function() {
							const resultsSection = document.getElementById('resultsSection');
							const resultsJson = document.getElementById('resultsJson');
							
							if (resultsSection) {
								if (resultsSection.style.display === 'block') {
									console.log('[Search] ‚úÖ‚úÖ‚úÖ Results section is VISIBLE');
								} else {
									console.error('[Search] ‚ùå Results section display is:', resultsSection.style.display);
									console.log('[Search] ‚ö†Ô∏è Forcing results section to be visible...');
									resultsSection.style.display = 'block';
								}
							} else {
								console.error('[Search] ‚ùå Results section element not found!');
							}
							
							if (resultsJson && resultsJson.textContent && resultsJson.textContent.length > 0) {
								console.log('[Search] ‚úÖ‚úÖ‚úÖ Results JSON content is present (' + resultsJson.textContent.length + ' chars)');
							} else {
								console.error('[Search] ‚ùå Results JSON content is empty or missing!');
								// Try to re-display
								if (apiResponse && displayFunc) {
									console.log('[Search] üîÑ Attempting to re-display results...');
									displayFunc(apiResponse);
								}
							}
						}, 800);
						
						// After displayResults, re-initialize comparison controls to restore the button
						setTimeout(function() {
							console.log('[Search] üîÑ Re-initializing comparison controls after restoration...');
							try {
								initializeComparisonControls();
								console.log('[Search] ‚úÖ Comparison controls re-initialized');
								
								// Clear selected properties on page load/refresh
								selectedProperties = [];
								
								// Update compare controls to show empty selection
									const compareControls = document.getElementById('compareControls');
									const selectedCount = document.getElementById('selectedCount');
									const compareButton = document.getElementById('compareButton');
									
									if (compareControls && selectedCount && compareButton) {
									selectedCount.textContent = '0';
											compareButton.disabled = true;
											compareButton.style.opacity = '0.6';
									compareControls.style.display = 'none';
										}
								
								// Clear stored selected properties from AppState
								if (AppState && AppState.setSelectedProperties) {
									AppState.setSelectedProperties([]);
									}
								
								console.log('[Search] ‚úÖ Selected properties cleared on page load');
							} catch (controlError) {
								console.warn('[Search] ‚ö†Ô∏è Error re-initializing comparison controls:', controlError);
							}
						}, 300);
					} catch (error) {
						console.error('[Search] ‚ùå‚ùå‚ùå ERROR calling displayResults:', error);
						console.error('[Search] Error name:', error.name);
						console.error('[Search] Error message:', error.message);
						console.error('[Search] Error stack:', error.stack);
						alert('Error restoring results: ' + error.message + '\n\nCheck console for details.');
					}
				} else {
					const attempts = (tryDisplayResults.attempts || 0) + 1;
					console.log('[Search] ‚è≥ displayResults not ready yet, waiting... (attempt ' + attempts + '/10)');
					// Try again after a short delay (max 10 tries)
					if (attempts < 10) {
						tryDisplayResults.attempts = attempts;
						setTimeout(tryDisplayResults, 100);
					} else {
						console.error('[Search] ‚ùå displayResults never became available after 10 attempts');
						console.error('[Search] Available functions:', Object.keys(window).filter(k => typeof window[k] === 'function' && k.includes('display')).slice(0, 10));
						console.log('[Search] üîÑ Attempting DIRECT restoration instead...');
						
						// Use direct restoration as fallback
						const directSuccess = restoreResultsDirectly();
						if (directSuccess) {
							console.log('[Search] ‚úÖ‚úÖ‚úÖ Direct restoration succeeded!');
						} else {
							console.error('[Search] ‚ùå Direct restoration also failed');
							const resultsSection = document.getElementById('resultsSection');
							if (resultsSection) {
								// resultsSection.style.display = 'block'; // Currently hidden per user request
								console.log('[Search] ‚ö†Ô∏è Results section is hidden per user request');
								alert('Warning: Could not restore results automatically. The displayResults function was not available.\n\nPlease try making a new search.');
							}
						}
					}
				}
			}
			
			// Try to use displayResults function first, but use direct restoration as backup
			setTimeout(function() {
				// Try to find displayResults
				const displayFunc = typeof displayResults === 'function' ? displayResults : 
				                   (typeof window !== 'undefined' && typeof window.displayResults === 'function' ? window.displayResults : null);
				
				if (displayFunc) {
					console.log('[Search] ‚úÖ Found displayResults, using it...');
					try {
						displayFunc(apiResponse);
						console.log('[Search] ‚úÖ displayResults() called successfully');
					} catch (error) {
						console.error('[Search] ‚ùå Error calling displayResults:', error);
						console.log('[Search] üîÑ Falling back to direct restoration...');
						restoreResultsDirectly();
					}
				} else {
					console.log('[Search] ‚ö†Ô∏è displayResults not found, using direct restoration...');
					restoreResultsDirectly();
				}
				
				// Re-initialize comparison controls after restoration
				setTimeout(function() {
					try {
						// Reset initialization flag to allow re-initialization
						comparisonControlsInitialized = false;
						initializeComparisonControls();
						
						// Clear selected properties on page load/refresh to start fresh
							selectedProperties = [];
							
						// Uncheck all checkboxes to ensure clean state
							const allCheckboxes = document.querySelectorAll('input[type="checkbox"][data-compare-id]');
							allCheckboxes.forEach(checkbox => {
								checkbox.checked = false;
							});
							
						// Clear stored selected properties from AppState
						if (AppState && AppState.setSelectedProperties) {
							AppState.setSelectedProperties([]);
							console.log('[Search] ‚úÖ Cleared stored selected properties on page load');
						}
						
						// Update compare controls to reflect empty selection
							const compareControls = document.getElementById('compareControls');
							const selectedCount = document.getElementById('selectedCount');
							const compareButton = document.getElementById('compareButton');
							
							if (compareControls && selectedCount && compareButton) {
							selectedCount.textContent = '0';
									compareButton.disabled = true;
									compareButton.style.opacity = '0.6';
							compareControls.style.display = 'none';
								}
						
						console.log('[Search] ‚úÖ Selected properties cleared on page load');
					} catch (error) {
						console.warn('[Search] ‚ö†Ô∏è Error restoring comparison controls:', error);
					}
				}, 300);
			}, 250);
			
			console.log('[Search] ‚úÖ Page restoration initiated');
		}
		
		// Global function to manually test storage (can be called from console)
		window.testPropintelliStorage = function() {
			console.log('=== Testing PropIntelli Storage ===');
			testStorageAvailability();
			
			// Try to store a test value
			try {
				const testData = {
					response: { test: 'data', timestamp: Date.now() },
					source: 'manual_test',
					timestamp: new Date().toISOString()
				};
				localStorage.setItem('propintelli_api_response', JSON.stringify(testData));
				console.log('‚úÖ Test data stored');
				
				// Try to retrieve it
				const retrieved = localStorage.getItem('propintelli_api_response');
				if (retrieved) {
					const parsed = JSON.parse(retrieved);
					console.log('‚úÖ Test data retrieved successfully:', parsed);
				} else {
					console.error('‚ùå Test data could not be retrieved');
				}
			} catch (error) {
				console.error('‚ùå Error during test:', error);
			}
			
			// Show current storage status
			console.log('Current localStorage keys:', Object.keys(localStorage).filter(k => k.startsWith('propintelli_')));
		};
	</script>
	<script src="app.js"></script>
</body>
</html>

